<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TOU Notepad</title>
    <link rel="icon" style="border-radius: 8px;" type="image/png" href="Untitled design.png" />
    <link rel="manifest" href="/site.webmanifest">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <style>
        /* Apparent dropdown for role cards */
        .role-card-dropdown {
            appearance: none;
            border: none; /* remove border */
            border-radius: 8px;
            padding: 10px 20px; /* larger clickable area */
            font-size: 20px; /* slightly bigger text */
            background-color: #1f1f1f; /* let card background show */
            color: #e2e2e2;
            margin: 6px 0;
            width: 90%;
            box-shadow: none;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.12s;
        }
        .role-card-dropdown:focus, .role-card-dropdown:hover {
            outline: none;
            background-color: rgba(0,0,0,0.15);
            color: #fff;
        }
        /* dropdown chevron removed as it overlapped text */
        @font-face {
            font-family: 'Amatic SC';
            src: url('0a1915693ca58e3e-s.p.woff') format('woff');
            font-weight: normal;
        }

        video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1; /* Ensure video is behind other content */
}

        body {
            background-color: #1e1e19;
            font-family: 'Amatic SC', sans-serif;
            letter-spacing: 1.4px;
            color: #E2E8F0;
        }

        .container {
            background-color: #32322c;
            opacity: 0.99;
            margin-top: 15px;
            max-width: 3000px;
            width: 95%;
        }

        .notepad-paper-background {
            background-color: #232323;
            background-image: linear-gradient(to bottom, transparent 24px, #e0e0e0 27px, transparent 28px);
            background-size: 100% 25px;
            background-position: 0 0;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            flex-grow: 1;
            position: relative;
            z-index: 1;
        }

        .notepad-textarea {
            background-color: transparent;
            border: none;
            font-size: 25px;
            resize: both;
            outline: none;
            color: inherit;
            min-height: 200px;
        }

        .custom-scrollable-container::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollable-container::-webkit-scrollbar-track {
            background: #2a2a26;
            border-radius: 10px;
        }

        .custom-scrollable-container::-webkit-scrollbar-thumb {
            background-color: #404038;
            border-radius: 10px;
            border: 2px solid #2a2a26;
        }

        .tab-button {
            padding: 8px 16px;
            border-radius: 8px 8px 0 0;
            background-color: #2a2a26;
            color: #A0AEC0;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            font-size: 20px;
            letter-spacing: 1px;
        }

        .tab-button:hover {
            background-color: #404038;
        }

        .tab-button.active {
            background-color: #404038;
            color: #E2E8F0;
            font-weight: 1000;
        }

        .close-tab-btn {
            margin-left: 8px;
            font-size: 20px;
            cursor: pointer;
            color: #F56565;
            transition: color 0.2s;
        }

        .close-tab-btn:hover {
            color: #F56565;
        }

        #addTabButton {
            background-color: #2a2a26;
            color: #E2E8F0;
            border-radius: 9px;
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 50px;
            padding-bottom: 10px;
            font-weight: bold;
            line-height: 1;
            margin-left: 8px;
            transition: background-color 0.2s;
        }

        #addTabButton:hover {
            background-color: #404038;
        }

        .role-card-input-container {
            display: none;
            background-color: #2a2a26;
        }

        #rolesContentDiv {
    display: flex;
    flex-wrap: wrap;       /* allow wrapping to next line */
    gap: 2rem;             /* spacing between cards */
    justify-content: flex-start; /* align left, can also use center */
}

        .role-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.8rem;
            background: rgba(40, 0, 0, 0.85);
            border: 2px solid #ff1a1a;
            border-radius: 12px;
            margin-bottom: 1rem;
            margin-left: 20px;
            position: relative;
            transition: transform 0.2s ease, box-shadow 0.3s ease;
            cursor: pointer;
            box-shadow: 0 0 12px rgba(255, 0, 0, 0.4), inset 0 0 6px rgba(255, 0, 0, 0.2);
            width: 170px;
            flex-shrink: 0;
        }

        .role-card:hover {
            transform: scale(1.01);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.8), inset 0 0 8px rgba(255, 0, 0, 0.3);
        }
        
        /* Removed role-card-content, role-card-info, role-card-text, role-card-bucket for new vertical layout */

        .role-card-icon {
            width: 80px;
            height: 80px;
            margin: 0.5rem 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
        }

        .role-card-name {
            font-weight: bold;
            color: #fff;
            font-size: 22px;
            margin-bottom: 0.2rem;
        }
        .role-card-role {
            font-weight: bold;
            color: #ff1a1a;
            font-size: 22px;
            margin-top: 0.5rem;
            margin-bottom: 0.2rem;
        }

        .delete-role-card-button {
    position: absolute;
    top: -20px; /* slightly down from top */
    right: 3px; /* slightly in from right */
    color: #ff2e2e;
    padding: 0rem 0.2rem;
    font-size: 50px; /* larger size */
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s, box-shadow 0.2s;
    z-index: 10;
}

.delete-role-card-button:hover {
    filter: drop-shadow(0 0 8px #ff4c4c);
}

        .role-card-detail {
            font-size: 1rem;
            line-height: 1.4;
        }
        
        .menu-button {
            padding: 8px;
        }
        #resetButton {
            background-color: #900000;
            color: rgb(252, 105, 105);
            font-weight: bold;
            padding: 0.5rem 1rem;
            font-size: 22px;
            letter-spacing: 1px;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
        }
        .menu-item {
            font-size: 22px;
            color: #E2E8F0;
            background-color: #2a2a26;
            padding: 0.5rem 1rem;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            width: 100%;
            border-radius:2px ;
            box-sizing: border-box;
        }
        .menu-item:hover {
            background-color: #404038;
        }
        #closeIframe {
            background-color: #900000;
            color: rgb(252, 105, 105);
            font-weight: bold;
            padding: 0.3rem 0.5rem;
            font-size: 22px;
            letter-spacing: 1px;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
        }
        #closeIframe:hover {
            background-color: #b30000;
        }
         /* Add this new CSS block */
    .role-card-dropdown-container {
        position: left; /* Essential for positioning the menu inside the card */
        width: 100%;
        text-align: center;
        margin-top: 5px;
    }

    .role-card-role-display {
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* --- New Styles for Role Cycling Arrows --- */
.role-card-cycle-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    width: 100%; 
}

.cycle-role-button {
    background: none;
    border: none;
    color: var(--main-color, #E2E8F0); /* Inherits color from the role */
    font-size: 1.5rem; 
    cursor: pointer;
    padding: 0 5px;
    transition: color 0.2s;
    line-height: 1; /* Ensures vertical alignment */
}

.cycle-role-button:hover {
    color: #fff;
}

.role-card-role {
    flex-grow: 1;
    text-align: center;
    white-space: nowrap;
    overflow: hidden; /* Prevent text from escaping if too long */
    text-overflow: ellipsis; 
}
        /* --- Animations --- */
        @keyframes poof-out {
            0% { transform: scale(1) rotate(0deg); opacity: 1; filter: blur(0px); }
            40% { transform: scale(1.08) rotate(-6deg); opacity: 0.9; }
            100% { transform: scale(0.1) rotate(10deg); opacity: 0; filter: blur(6px); }
        }

        .animate-poof {
            animation: poof-out 420ms cubic-bezier(.4,0,.2,1) forwards;
        }

        @keyframes tab-slide {
            0% { opacity: 0; transform: translateY(8px) scale(0.98); }
            60% { opacity: 1; transform: translateY(-4px) scale(1.01); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        .animate-tab {
            animation: tab-slide 360ms cubic-bezier(.2,.9,.2,1) both;
        }

        @keyframes role-pulse {
            0% { transform: scale(1); box-shadow: 0 0 8px rgba(0,0,0,0.0); }
            40% { transform: scale(1.04); box-shadow: 0 8px 20px rgba(0,0,0,0.25); }
            100% { transform: scale(1); box-shadow: none; }
        }
        .animate-role-change {
            animation: role-pulse 300ms cubic-bezier(.2,.8,.2,1) both;
        }

        /* Card enter animation */
        @keyframes card-enter {
            0% { opacity: 0; transform: translateY(8px) scale(0.98); }
            60% { opacity: 1; transform: translateY(-4px) scale(1.02); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        .animate-card-enter { animation: card-enter 300ms cubic-bezier(.2,.9,.2,1) both; }

        /* Menu open animation */
        @keyframes menu-open {
            0% { opacity: 0; transform: translateY(-6px) scale(0.98); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }
        .animate-menu-open { animation: menu-open 180ms cubic-bezier(.2,.8,.2,1) both; }

        /* Reset modal styles */
        .reset-modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 9998; }
        .reset-modal { position: fixed; z-index: 9999; left: 50%; top: 50%; transform: translate(-50%, -50%); background: #111; color: #fff; border-radius: 10px; padding: 18px; width: 90%; max-width: 460px; box-shadow: 0 10px 40px rgba(0,0,0,0.6); }
        .reset-modal h3 { margin: 0 0 6px 0; font-size: 20px; }
        .reset-modal p { margin: 0 0 12px 0; color: #ddd; }
        .reset-modal .btn { padding: 8px 12px; border-radius: 8px; cursor: pointer; border: none; }
        .reset-modal .btn-cancel { background: #333; color: #fff; }
        .reset-modal .btn-confirm { background: #c53030; color: #fff; }
        /* Floating notepad pane (movable, always-on-top within page) */
        .floating-pane {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 420px;
            height: 420px;
            background: #171717;
            border-radius: 10px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.6), 0 4px 12px rgba(0,0,0,0.3);
            z-index: 100000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.04);
        }
        .floating-pane.hidden { display: none; }
        .floating-pane .fp-header {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            cursor: move;
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
            border-bottom: 1px solid rgba(255,255,255,0.02);
        }
        .floating-pane .fp-header .title { font-weight: 700; color: #fff; font-size: 16px; }
        .floating-pane .fp-controls { display:flex; gap:8px; }
        .floating-pane .fp-controls button { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; padding:4px 8px; border-radius:6px; cursor:pointer; }
        .floating-pane .fp-body { flex:1; overflow:auto; padding:8px; background: transparent; }
    </style>
</head>
<body>
    <video autoplay muted loop src="videoplayback.mp4">
        <source src="videoplayback.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
<div class="container mx-auto p-8 rounded-lg shadow-xl relative z-10 w-[95%] sm:w-2/3 md:w-3/4 lg:w-2/3 xl:w-2/3 min-h-[75vh] flex flex-col justify-between">
    <div class="flex justify-between items-center mb-4">
        <div class="flex items-center space-x-4">
            <img src="MiraNotepadLogo.png" alt="TOU Logo" style="border-radius: 9px;" class="w-16 h-16 sm:w-20 sm:h-20 md:w-24 md:h-24">
            <h1><img src="toulogo.png" style="height: 120px;"></h1>
        </div>
        <div class="relative inline-block text-left" id="dropdownMenu">
            <button href="wiki.html" style="font-size: 25px; width: 100%; letter-spacing: 1.2px; font-weight: 700; color:#fa5858; "target="_blank" role="menuitem" onclick="openIframe('wiki.html')"><img src="wikiButton.png" class="w-16 h-16 sm:w-20 sm:h-20 md:w-24 md:h-24" style="filter: drop-shadow(0 0 2px black);"> Wiki</button>
            <div style="background-color: #2a2a26;" class="absolute right-0 mt-2 w-48 rounded-md shadow-lg ring-1 ring-black ring-opacity-5 hidden z-40">
            </div>
        </div>
    </div>

    <div id="iframeOverlay" class="fixed inset-0 bg-black bg-opacity-75 hidden justify-center items-center z-50">
        <div class="relative w-full h-full max-w-8xl max-h-4xl bg-gray-900 rounded-lg overflow-hidden">
            <button id="closeIframe" class="absolute top-2 right-2 text-white bg-gray-700 p-2 rounded-full hover:bg-gray-600 z-50">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <iframe id="dynamicIframe" src="" class="w-full h-full border-none"></iframe>
        </div>
    </div>

    <div class="flex items-end mb-4">
        <div id="tabsContainer" class="flex flex-wrap space-x-2"></div>
        <button id="addTabButton" class="add-tab-button">+</button>
    </div>
    
    <div id="notesContentDiv" class="flex-grow flex flex-col notepad-paper-background p-4"></div>
    
    <div id="rolesContentDiv" class="flex-grow flex hidden overflow-y-auto p-4 custom-scrollable-container"></div>
    
    <div class="flex justify-end mt-4">
        <button id="resetButton" class="bg-red-500 text-white font-bold py-2 px-4 rounded-md hover:bg-red-600 transition duration-200">Reset</button>
    </div>
</div>
<!-- Hidden canvas + video for Notepad Picture-in-Picture -->
<canvas id="pipCanvas" width="640" height="360" style="display:none"></canvas>
<!-- offscreen but present video element: some browsers require the video to be present/played before PiP -->
<video id="pipVideo" muted playsinline style="position:fixed; left:-10000px; top:0; width:1px; height:1px; opacity:0;"></video>

<!-- Floating notepad pane (will move the notes container into this element while floating) -->
<div id="floatingNotepad" class="floating-pane hidden" aria-hidden="true">
    <div class="fp-header" id="fpHeader" role="toolbar">
        <div class="title">Notepad (Floating)</div>
        <div class="fp-controls">
            <button id="fpDockBtn" title="Dock back">Dock</button>
            <button id="fpCloseBtn" title="Close">Close</button>
        </div>
    </div>
    <div class="fp-body" id="fpContent"></div>
</div>
<script>
    // --- Main State Variables ---
    let notesTabs = {};
    let activeTab = 'Notes';
    let tabCounter = 1;
    let roleCards = [];
    // Track any open floating menu so we can close it and ensure it stays on the top layer
    let currentOpenFloatingMenu = null;

    // ...existing code...

    // --- DOM Elements ---
    const tabsContainer = document.getElementById('tabsContainer');
    const notesContentDiv = document.getElementById('notesContentDiv');
    const rolesContentDiv = document.getElementById('rolesContentDiv');
    const addTabButton = document.getElementById('addTabButton');
    const resetButton = document.getElementById('resetButton');
    const dropdownMenu = document.getElementById('dropdownMenu');
    const dynamicIframe = document.getElementById('dynamicIframe');
    const iframeOverlay = document.getElementById('iframeOverlay');
    const closeIframeButton = document.getElementById('closeIframe');
    
    // --- Regex for parsing role card input ---
    const roleCardRegex = /(.+) is(?: (not|probably|likely))? (.+)/i;

    // Phrase -> roles mapping (exact phrases the user requested)
    // Each regex captures the player name in group 1. Allow optional trailing punctuation.
    const phraseRolePatterns = [
        { re: /^(.+?)\s+spreads fear amongst the group[\.\!\?]?$/i, roles: ['Plaguebearer','Hypnotist','Miner','Ambusher','Prosecutor','Seer','Arsonist','Transporter'] },
        { re: /^(.+?)\s+is well trained in hunting down prey[\.\!\?]?$/i, roles: ['Scavenger','Investigator','Tracker','Werewolf','Hunter','Lookout','Inquisitor','Swooper'] },
        { re: /^(.+?)\s+has an insight for private information[\.\!\?]?$/i, roles: ['Blackmailer','Detective','Doomsayer','Mercenary','Oracle','Ambassador','Snitch','Trapper'] },
        { re: /^(.+?)\s+hides to guard themselves or others[\.\!\?]?$/i, roles: ['Cleric','Escapist','Engineer','Grenadier','Guardian Angel','Medic','Mirrorcaster','Survivor','Warden'] },
        { re: /^(.+?)\s+is capable of performing relentless attacks[\.\!\?]?$/i, roles: ['Deputy','Bomber','Jailor','Juggernaut','Vigilante','Sheriff','Warlock'] },
        { re: /^(.+?)\s+has an altered perception of reality[\.\!\?]?$/i, roles: ['Aurial','Imitator','Eclipsal','Glitch','Morphling','Mystic','Spy'] },
        { re: /^(.+?)\s+has a trick up their sleeve[\.\!\?]?$/i, roles: ['Swapper','Jester','Executioner','Traitor','Politician','Plumber','Venerer','Veteran'] },
        { re: /^(.+?)\s+has an unusual obsession with dead bodies[\.\!\?]?$/i, roles: ['Altruist','Amnesiac','Medium','Soul Collector','Undertaker','Vampire'] }
    ];

    // Function to convert RGB float values (0-1) to a hex color string (#RRGGBB).
    function rgbFloatToHex(r, g, b) {
        const toHex = (c) => {
            const hex = Math.round(c * 255).toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        };
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    // --- Role/Team/Modifier Colors & Data ---
    const roleColors = {
        "Crewmate": rgbFloatToHex(0.00, 0.75, 1.00),
        "Mayor": rgbFloatToHex(0.44, 0.31, 0.66),
        "Sheriff": rgbFloatToHex(1.00, 1.00, 0.00),
        "Engineer": rgbFloatToHex(1.00, 0.65, 0.04),
        "Swapper": rgbFloatToHex(0.40, 0.90, 0.40),
        "Investigator": rgbFloatToHex(0.00, 0.70, 0.70),
        "Medic": rgbFloatToHex(0.00, 0.40, 0.00),
        "Seer": rgbFloatToHex(1.00, 0.80, 0.50),
        "Spy": rgbFloatToHex(0.80, 0.64, 0.80),
        "Snitch": rgbFloatToHex(0.83, 0.69, 0.22),
        "Altruist": rgbFloatToHex(0.40, 0.00, 0.00),
        "Vigilante": rgbFloatToHex(1.00, 1.00, 0.60),
        "Veteran": rgbFloatToHex(0.60, 0.50, 0.25),
        "Haunter": rgbFloatToHex(0.83, 0.83, 0.83),
        "Transporter": rgbFloatToHex(0.00, 0.93, 1.00),
        "Mirrorcaster": '#5e80a2',
        "Medium": rgbFloatToHex(0.65, 0.50, 1.00),
        "Mystic": rgbFloatToHex(0.30, 0.60, 0.90),
        "Trapper": rgbFloatToHex(0.65, 0.82, 0.70),
        "Detective": rgbFloatToHex(0.30, 0.30, 1.00),
        "Imitator": rgbFloatToHex(0.70, 0.85, 0.30),
        "Prosecutor": rgbFloatToHex(0.70, 0.50, 0.00),
        "Oracle": rgbFloatToHex(0.75, 0.00, 0.75),
        "Aurial": rgbFloatToHex(0.70, 0.30, 0.60),
        "Politician": rgbFloatToHex(0.40, 0.00, 0.60),
        "Warden": rgbFloatToHex(0.60, 0.00, 1.00),
        "Jailor": rgbFloatToHex(0.65, 0.65, 0.65),
        "Hunter": rgbFloatToHex(0.16, 0.67, 0.53),
        "Tracker": rgbFloatToHex(0.00, 0.60, 0.00),
        "Lookout": rgbFloatToHex(0.20, 1.00, 0.40),
        "Deputy": rgbFloatToHex(1.00, 0.80, 0.00),
        "Plumber": rgbFloatToHex(0.80, 0.40, 0.00),
        "Cleric": rgbFloatToHex(0.00, 1.00, 0.70),

        "Neutral": rgbFloatToHex(0.50, 0.50, 0.50),
        "Jester": rgbFloatToHex(1.00, 0.75, 0.80),
        "Executioner": rgbFloatToHex(0.39, 0.23, 0.12),
        "Glitch": rgbFloatToHex(0.00, 1.00, 0.00),
        "Arsonist": rgbFloatToHex(1.00, 0.30, 0.00),
        "Amnesiac": rgbFloatToHex(0.50, 0.70, 1.00),
        "Juggernaut": rgbFloatToHex(0.55, 0.00, 0.30),
        "Survivor": rgbFloatToHex(1.00, 0.90, 0.30),
        "Protector": rgbFloatToHex(0.70, 1.00, 1.00),
        "Plaguebearer": rgbFloatToHex(0.90, 1.00, 0.70),
        "Pestilence": rgbFloatToHex(0.30, 0.30, 0.30),
        "Werewolf": rgbFloatToHex(0.66, 0.40, 0.16),
        "Doomsayer": rgbFloatToHex(0.00, 1.00, 0.50),
        "Vampire": rgbFloatToHex(0.64, 0.16, 0.16),
        "Soul Collector": rgbFloatToHex(0.60, 1.00, 0.80),
        "Guardian Angel": rgbFloatToHex(0.70, 1.00, 1.00),
        "Phantom": rgbFloatToHex(0.40, 0.16, 0.38),
        "Mercenary": rgbFloatToHex(0.55, 0.40, 0.60),
        "Inquisitor": rgbFloatToHex(0.85, 0.26, 0.57),

        "Impostor": '#d73f42',
        "ImpSoft": '#d73f42',
        "Eclipsal": '#d73f42',
        "Escapist": '#d73f42',
        "Grenadier": '#d73f42',
        "Morphling": '#d73f42',
        "Ambassador": '#d73f42',
        "Ambusher": '#d73f42',
        "Swooper": '#d73f42',
        "Venerer": '#d73f42',
        "Bomber": '#d73f42',
        "Scavenger": '#d73f42',
        "Traitor": '#d73f42',
        "Warlock": '#d73f42',
        "Blackmailer": '#d73f42',
        "Hypnotist": '#d73f42',
        "Janitor": '#d73f42',
        "Miner": '#d73f42',
        "Undertaker": '#d73f42'
    };

    const modifierColors = {
        "Bait": rgbFloatToHex(0.20, 0.70, 0.70),
        "Aftermath": rgbFloatToHex(0.65, 1.00, 0.65),
        "Diseased": rgbFloatToHex(0.50, 0.50, 0.50),
        "Torch": rgbFloatToHex(1.00, 1.00, 0.60),
        "Button Barry": rgbFloatToHex(0.70, 0.20, 0.80),
        "Flash": rgbFloatToHex(1.00, 0.50, 0.50),
        "Giant": rgbFloatToHex(1.00, 0.70, 0.30),
        "Lover": rgbFloatToHex(1.00, 0.40, 0.80),
        "Sleuth": rgbFloatToHex(0.50, 0.20, 0.20),
        "Tiebreaker": rgbFloatToHex(0.60, 0.90, 0.60),
        "Radar": rgbFloatToHex(1.00, 0.00, 0.50),
        "Multitasker": rgbFloatToHex(1.00, 0.50, 0.30),
        "Frosty": rgbFloatToHex(0.60, 1.00, 1.00),
        "Sixth Sense": rgbFloatToHex(0.85, 1.00, 0.55),
        "Shy": rgbFloatToHex(1.00, 0.70, 0.80),
        "Mini": rgbFloatToHex(0.80, 1.00, 0.90),
        "Camouflaged": rgbFloatToHex(0.50, 0.50, 0.50),
        "Satellite": rgbFloatToHex(0.00, 0.60, 0.80),
        "Egotist": rgbFloatToHex(0.40, 0.60, 0.40),
        "Lovers": rgbFloatToHex(1.00, 0.40, 0.80),
        "Taskmaster": rgbFloatToHex(0.58, 0.84, 0.93),
        "Celebrity": rgbFloatToHex(1.00, 0.60, 0.60),
        "Immovable": rgbFloatToHex(0.90, 0.90, 0.80),
        "Rotting": rgbFloatToHex(0.67, 0.50, 0.41),
        "Noisemaker": rgbFloatToHex(0.91, 0.41, 0.62),
        "Scientist": rgbFloatToHex(0.00, 0.78, 0.41),
        "Operative": rgbFloatToHex(0.60, 0.03, 0.07),
        "Scout": rgbFloatToHex(0.27, 0.38, 0.34),

        "Disperser": '#d73f42',
        "Double Shot": '#d73f42',
        "Saboteur": '#d73f42',
        "Underdog": '#d73f42',
        "Telepath": '#d73f42',
        "Spy Modifier": rgbFloatToHex(0.80, 0.64, 0.80)
    };

    const allEntitiesData = [
    // Crewmate Roles
    {
        category: "Role", name: "Aurial", team: "Crewmate",
        icon: 'Aurial',
    },
    {
        category: "Role", name: "Detective", team: "Crewmate",
        icon: 'Detective',
    },
    {
        category: "Role", name: "Engineer", team: "Crewmate",
        icon: 'Engineer',
    },
    {
        category: "Role", name: "Medic", team: "Crewmate",
        icon: 'Medic',
    },
    {
        category: "Role", name: "Sheriff", team: "Crewmate",
        description: "The Sheriff is a Crewmate that has the ability to eliminate the Impostors using their kill button.\nHowever, if they kill a Crewmate or a Neutral player they can't kill, they instead die themselves.",
        abilities: [{ name: "Shoot", icon: 'SheriffShootButton.png', description: "Eliminates Impostors. Miskilling results in self-elimination." }],
        icon: 'Sheriff',
        types: ["Killing"],
        options: [
            { name: "Sheriff", description: "The percentage probability of the Sheriff appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Sheriff Miskill Kills Crewmate", description: "Whether the other player is killed if the Sheriff Misfires", type: "Toggle", default: "False", range: "N/A" },
            { name: "Sheriff Kills Neutral Evil Roles", description: "Whether the Sheriff is able to kill a Neutral Evil Role", type: "Toggle", default: "False", range: "N/A" },
            { name: "Sheriff Kills Neutral Killing Roles", description: "Whether the Sheriff is able to kill a Neutral Killing Role", type: "Toggle", default: "False", range: "N/A" },
            { name: "Sheriff Kill Cooldown", description: "The cooldown on the Sheriff's kill button", type: "Time", default: "25s", range: "N/A" },
            { name: "Sheriff can report who they've killed", description: "Whether the Sheriff is able to report their own kills", type: "Toggle", default: "True", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Snitch", team: "Crewmate",
        description: "The Snitch is a \nCrewmate that can get arrows pointing towards the Impostors, once all their tasks are finished.\nThe names of the Impostors will also show up as red on their screen.\nHowever, when they only have a single task left, the Impostors get an arrow pointing towards the Snitch.",
        abilities: [],
        icon: 'Snitch',
        types: ["Information"],
        options: [
            { name: "Snitch", description: "The percentage probability of the Snitch appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Snitch Sees Neutral Roles", description: "Whether the Snitch also Reveals Neutral Roles", type: "Toggle", default: "False", range: "N/A" },
            { name: "Tasks Remaining When Revealed", description: "The number of tasks remaining when the Snitch is revealed to Impostors", type: "Number", default: "1", range: "N/A" },
            { name: "Snitch Sees Impostors in Meetings", description: "Whether the Snitch sees the Impostor's names red in Meetings", type: "Toggle", default: "True", range: "N/A" },
            { name: "Snitch Sees Traitor", description: "Whether the Snitch sees the \nTraitor", type: "Toggle", default: "True", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Chef", team: "Neutral",
        description: "The Sheriff is a Crewmate that has the ability to eliminate the Impostors using their kill button.\nHowever, if they kill a Crewmate or a Neutral player they can't kill, they instead die themselves.",
        abilities: [{ name: "Shoot", icon: 'SheriffShootButton.png', description: "Eliminates Impostors. Miskilling results in self-elimination." }],
        icon: 'Chef',
        types: ["Evil"],
        options: [
            { name: "Sheriff", description: "The percentage probability of the Sheriff appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Sheriff Miskill Kills Crewmate", description: "Whether the other player is killed if the Sheriff Misfires", type: "Toggle", default: "False", range: "N/A" },
            { name: "Sheriff Kills Neutral Evil Roles", description: "Whether the Sheriff is able to kill a Neutral Evil Role", type: "Toggle", default: "False", range: "N/A" },
            { name: "Sheriff Kills Neutral Killing Roles", description: "Whether the Sheriff is able to kill a Neutral Killing Role", type: "Toggle", default: "False", range: "N/A" },
            { name: "Sheriff Kill Cooldown", description: "The cooldown on the Sheriff's kill button", type: "Time", default: "25s", range: "N/A" },
            { name: "Sheriff can report who they've killed", description: "Whether the Sheriff is able to report their own kills", type: "Toggle", default: "True", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Swapper", team: "Crewmate",
        description: "The Swapper is a Crewmate that can swap the votes on 2 players during a meeting.\nAll the votes for the first player will instead be counted towards the second player and vice versa.",
        abilities: [{ name: "Swap", icon: 'SwapActive.png', description: "Swaps votes between two players during a meeting." }],
        icon: 'Swapper',
        types: ["Support", "Utility"],
        options: [
            { name: "Swapper", description: "The percentage probability of the Swapper appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Swapper Can Button", description: "Whether the Swapper Can Press the Button", type: "Toggle", "default": "True", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Transporter", team: "Crewmate",
        description: "The Transporter is a Crewmate that can change the locations of two random players at will.\nPlayers who have been transported are alerted with a blue flash on their screen.",
        abilities: [{ name: "Transport", icon: 'TransportButton.png', description: "Changes the locations of two random players." }],
        icon: 'Transporter',
        types: ["Utility"],
        options: [
            { name: "Transporter", description: "The percentage probability of the Transporter appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Transport Cooldown", description: "The cooldown of the Transporter's transport ability", type: "Time", "default": "25s", range: "N/A" },
            { name: "Max Uses", description: "The amount of times the Transport ability can be used", type: "Number", "default": "5", range: "N/A" },
            { name: "Transporter can use Vitals", description: "Whether the Transporter has the ability to use Vitals", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
     {
        category: "Role", name: "Haunter", team: "Crewmate",
        description: "Once a random Crewmate dies they become the Haunter. The Haunter has the ability to run around as a ghost and to do tasks. Once all tasks are finished they reveal the Impostors to all alive non-Impostors. However, if the Haunter is clicked they lose their ability to reveal Impostors and are once again a normal ghost. The Impostors also get a warning shortly before and as the Haunter finishes their tasks.",
        abilities: [],
        icon: 'Haunter',
        types: ["Detection", "Utility", "Other"],
        options: [
            { name: "Haunter", description: "The percentage probability of the Haunter appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "When Haunter Can Be Clicked", description: "The amount of tasks remaining when the Haunter Can Be Clicked", type: "Number", default: "5", range: "N/A" },
            { name: "Haunter Alert", description: "The amount of tasks remaining when the Impostors are alreted that the Haunter is nearly finished", type: "Number", default: "1", range: "N/A" },
            { name: "Haunter Reveals Neutral Roles", description: "Whether the Haunter also Reveals Neutral Roles", type: "Toggle", default: "False", range: "N/A" },
            { name: "Who can Click Haunter", description: "Whether even other Crewmates can click the Haunter", type: "All / Non-Crew / Imps Only", default: "All", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Investigator", team: "Crewmate",
        description: "The Investigator can see player's footprints throughout the game. Swooper footprints are hidden.",
        abilities: [],
        icon: 'Investigator',
        types: ["Detection"],
        options: [
            { name: "Investigator", description: "The percentage probability of the Investigator appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Footprint Size", description: "Changes how big footprints are.", type: "Multiplier", default: "4x", range: "1x - 10x" },
            { name: "Footprint Interval", description: "Changes how often footprints are created.", type: "Seconds", default: "1s", range: "0.5s - 6s" },
            { name: "Footprint Duration", description: "Changes how long footprints are visible for.", type: "Seconds", default: "10s", range: "1s - 15s" },
            { name: "Anonymous Footprint", description: "Determines if footprints are color coded based off the player.", type: "Toggle", default: "False", range: "N/A" },
            { name: "Show Vent Footprints", description: "Determines if footprints are visible from a player that's in a vent.", type: "Toggle", default: "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Lookout", team: "Crewmate",
        description: "The Lookout is a Crewmate that can watch other players during rounds. During meetings they will see all roles who interact with each watched player.",
        abilities: [{ name: "Watch", icon: 'WatchButton.png', description: "Watches other players during rounds to see who interacts with them." }],
        icon: 'Lookout',
        types: ["Detection"],
        options: [
            { name: "Lookout", description: "The percentage probability of the Lookout appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Watch Cooldown", description: "The cooldown on the Lookout's Watch button", type: "Time", default: "10s", range: "N/A" },
            { name: "Lookout Watches Reset After Each Round", description: "Whether Lookout Watches are removed after each meeting", type: "Toggle", default: "True", range: "N/A" },
            { name: "Maximum Number Of Players That Can Be Watched", description: "The number of people they can watch", type: "Number", default: "5", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Mystic", team: "Crewmate",
        description: "The Mystic is a Crewmate that gets an alert revealing when someone has died. On top of this, the Mystic briefly gets an arrow pointing in the direction of the body.",
        abilities: [],
        icon: 'Mystic',
        types: ["Detection", "Other"],
        options: [
            { name: "Mystic", description: "The percentage probability of the Mystic appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Arrow Duration", description: "The duration of the arrows pointing to the bodies", type: "Time", default: "0.1s", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Seer", team: "Crewmate",
        description: "The Seer is a Crewmate that can reveal the alliance of other players. Based on settings, the Seer can find out whether a player is a Good or an Evil role. A player's name will change color depending on faction and role.",
        abilities: [{ name: "Reveal", icon: 'SeerButton.png', description: "Reveals the alliance (Good/Evil) of other players." }],
        icon: 'Seer',
        types: ["Detection"],
        options: [
            { name: "Seer", description: "The percentage probability of the Seer appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Seer Cooldown", description: "The Cooldown of the Seer's Reveal button", type: "Time", default: "25s", range: "N/A" },
            { name: "Crewmate Killing Roles Are Red", description: "Crewmate Killing roles show up as Red", type: "Toggle", default: "False", range: "N/A" },
            { name: "Neutral Benign Roles Are Red", description: "Neutral Benign roles show up as Red", type: "Toggle", default: "False", range: "N/A" },
            { name: "Neutral Evil Roles Are Red", description: "Neutral Evil roles show up as Red", type: "Toggle", default: "False", range: "N/A" },
            { name: "Neutral Killing Roles Are Red", description: "Neutral Killing roles show up as Red", type: "Toggle", default: "True", range: "N/A" },
            { name: "Traitor does not swap Colours", description: "The Traitor remains their original colour", type: "Toggle", default: "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Spy", team: "Crewmate",
        description: "The Spy is a Crewmate Investigative role that gains extra information on the admin table. Not only does the Spy see how many people are in a room, but they will also see who is in every room. The Spy also has a toggle for a portable Admin Table with a limited battery charge.",
        abilities: [{ name: "Admin", icon: 'AdminButton.png', description: "Views detailed information on the admin table, including who is in each room." }],
        icon: 'Spy',
        types: ["Detection", "Utility"],
        options: [
            { name: "Spy", description: "The percentage probability of the Spy appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Who Sees Dead Bodies On Admin", description: "Which players see dead bodies on the admin map", type: "Nobody / Spy / Everyone But Spy / Everyone", default: "Nobody", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Tracker", team: "Crewmate",
        description: "The Tracker is a Crewmate that can track other players by tracking them during a round. Once they track someone, an arrow is continuously pointing to them, which updates in set intervals.",
        abilities: [{ name: "Track", icon: 'TrackButton.png', description: "Continuously tracks a player with a persistent arrow." }],
        icon: 'Tracker',
        types: ["Detection"],
        options: [
            { name: "Tracker", description: "The percentage probability of the Tracker appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Arrow Update Interval", description: "The time it takes for the arrow to update to the new location of the tracked player", type: "Time", default: "5s", range: "N/A" },
            { name: "Track Cooldown", description: "The cooldown on the Tracker's track button", type: "Time", default: "10s", range: "N/A" },
            { name: "Tracker Arrows Reset Each Round", description: "Whether Tracker Arrows are removed after each meeting", type: "Toggle", default: "True", range: "N/A" },
            { name: "Maximum Number of Tracks", description: "The number of people they can track", type: "Number", default: "5", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Trapper", team: "Crewmate",
        description: "The Trapper is a Crewmate that can place traps around the map. When players enter a trap they trigger the trap. In the following meeting, all players who triggered a trap will have their role displayed to the Trapper. However, this is done so in a random order, not stating who entered the trap, nor what role a specific player is.",
        abilities: [{ name: "Trap", icon: 'TrapButton.png', description: "Places traps that reveal roles of players who trigger them." }],
        icon: 'Trapper',
        types: ["Detection", "Utility"],
        options: [
            { name: "Trapper", description: "The percentage probability of the Trapper appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Min Amount of Time in Trap to Register", description: "How long a player must stay in the trap for it to trigger", type: "Time", default: "1s", range: "0s - 10s" },
            { name: "Trap Cooldown", description: "The cooldown on the Trapper's trap button", type: "Time", default: "10s", range: "N/A" },
            { name: "Traps Removed Each Round", description: "Whether the Trapper's traps are removed after each meeting", type: "Toggle", default: "True", range: "N/A" },
            { name: "Maximum Number of Traps", description: "The number of traps they can place", type: "Number", default: "5", range: "N/A" },
            { name: "Trap Size", description: "The size of each trap", type: "Factor", default: "0.25x", range: "N/A" },
            { name: "Minimum Number of Roles required to Trigger Trap", description: "The number of players that must enter the trap for it to be triggered", type: "Number", default: "3", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Deputy", team: "Crewmate",
        description: "The Deputy is a Crewmate that can camp other players. Camped players will alert the Deputy when they are killed. The following meeting the Deputy then can attempt to shoot their killer. If they successfully shoot the killer, they will die, otherwise nothing happens.",
        abilities: [
            { name: "Camp", icon: 'CampButton.png', description: "Camps players to be alerted if they are killed." },
            { name: "Shoot", icon: 'Shoot.png', description: "Attempts to shoot a killer in the following meeting." }
        ],
        icon: 'Deputy',
        types: ["Kill", "Detection"],
        options: [
            { name: "Deputy", description: "The percentage probability of the Deputy appearing", type: "Percentage", default: "0%", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Hunter", team: "Crewmate",
        description: "The Hunter is a Crewmate Killing role with the ability to track players and execute them if they do anything suspicious. Unlike the Sheriff, the Hunter does not die if they kill an innocent player, however the Hunter may only execute players who have given them probable cause.",
        abilities: [
            { name: "Stalk", icon: 'StalkButton.png', description: "Stalks players to find suspicious activity." },
            { name: "Kill", icon: 'HunterKillButton.png', description: "Executes players who have given probable cause." }
        ],
        icon: 'Hunter',
        types: ["Kill", "Detection"],
        options: [
            { name: "Hunter", description: "The percentage probability of the Hunter appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Hunter Kill Cooldown", description: "The cooldown of the Hunter's Kill button", type: "Number", default: "25s", range: "N/A" },
            { name: "Hunter Stalk Cooldown", description: "The cooldown of the Hunter's Stalk button", type: "Number", default: "10s", range: "N/A" },
            { name: "Hunter Stalk Duration", description: "The duration of the Hunter's Stalk", type: "Number", default: "25s", range: "N/A" },
            { name: "Maximum Stalk Uses", description: "Maximum number of times a Hunter can Stalk", type: "Number", default: "5", range: "N/A" },
            { name: "Hunter Kills Last Voter If Voted Out", description: "Whether the Hunter kills the last person that votes them if they are voted out", type: "Toggle", default: "False", range: "N/A" },
            { name: "Hunter Can Report Who They've Killed", description: "Whether the Hunter is able to report their own kills", type: "Toggle", default: "True", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Jailor", team: "Crewmate",
        description: "The Jailor is a Crewmate that can jail Crewmates. During meetings all players can see when a Crewmate is jailed. When someone is jailed they cannot use any meeting ability and no meeting ability can be used on them. The Jailor may privately communicate with the jailee. If the Jailor then thinks the jailee is bad, they may then execute them. If the Jailor executes incorrectly, they lose the ability to jail.",
        abilities: [
            { name: "Jail", icon: 'JailButton.png', description: "Jails Crewmates, preventing them from using meeting abilities." },
            { name: "Execute", icon: 'ExecuteClean.png', description: "Executes jailed players if deemed suspicious." }
        ],
        icon: 'Jailor',
        types: ["Kill", "Utility"],
        options: [
            { name: "Jailor", description: "The percentage probability of the Jailor appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Jail Cooldown", description: "The cooldown on the Jailor's jail button", type: "Time", default: "10s", range: "N/A" },
            { name: "Maximum Executes", description: "Maximum number of times a Jailor can Execute", type: "Number", default: "3", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Veteran", team: "Crewmate",
        description: "The Veteran is a Crewmate that can go on alert. When the Veteran is on alert, anyone, whether Crew, Neutral or Impostor, if they interact with the Veteran, they die.",
        abilities: [{ name: "Alert", icon: 'AlertButton.png', description: "Goes on alert, killing anyone who interacts with them." }],
        icon: 'Veteran',
        types: ["Kill", "Support"],
        options: [
            { name: "Veteran", description: "The percentage probability of the Veteran appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Can Be Killed On Alert", description: "Whether the Veteran dies when someone tries to kill them when they're on alert", type: "Toggle", default: "False", range: "N/A" },
            { name: "Alert Cooldown", description: "The cooldown on the Veteran's alert button.", type: "Time", default: "5s", range: "N/A" },
            { name: "Alert Duration", description: "The duration of the alert", type: "Time", default: "25s", range: "N/A" },
            { name: "Maximum Number of Alerts", description: "The number of times the Veteran can alert throughout the game", type: "Number", default: "3", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Vigilante", team: "Crewmate",
        description: "The Vigilante is a Crewmate that can kill during meetings. During meetings, the Vigilante can choose to kill someone by guessing their role, however, if they guess incorrectly, they die instead.",
        abilities: [{ name: "Guess", icon: 'Guess.png', description: "Kills a player during meetings by guessing their role. Miskill results in self-elimination." }],
        icon: 'Vigilante',
        types: ["Kill"],
        options: [
            { name: "Vigilante", description: "The percentage probability of the Vigilante appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Vigilante Kill", description: "The number of kill the Vigilante can do with his ability", type: "Number", default: "1", range: "N/A" },
            { name: "Vigilante Multiple Kill", description: "Whether the Vigilante can kill more than once per meeting", type: "Toggle", default: "False", range: "N/A" },
            { name: "Vigilante Guess Neutral Benign", description: "Whether the Vigilante can Guess Neutral Benign roles", type: "Toggle", default: "False", range: "N/A" },
            { name: "Vigilante Guess Neutral Evil", description: "Whether the Vigilante can Guess Neutral Evil roles", type: "Toggle", default: "False", range: "N/A" },
            { name: "Vigilante Guess Neutral Killing", description: "Whether the Vigilante can Guess Neutral Killing roles", type: "Toggle", default: "False", range: "N/A" },
            { name: "Vigilante Guess Impostor Modifiers", description: "Whether the Vigilante can Guess Impostor modifiers", type: "Toggle", default: "False", range: "N/A" },
            { name: "Vigilante Guess Lovers", description: "Whether the Vigilante can Guess Lovers", type: "Toggle", default: "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Altruist", team: "Crewmate",
        description: "The Altruist is a Crewmate that is capable of reviving dead players. The Altruist may attempt to revive all dead players from that round. When reviving the Altruist may not move and all killers will be pointed towards the Altruist. After a set period of time, all dead player's bodies within the Altruist's range will be resurrected, if the revival isn't interrupted. Once a revival is used, the Altruist, along with all revived players will not be able to button for the remainder of the game.",
        abilities: [{ name: "Revive", icon: 'ReviveButton.png', description: "Revives dead players within a certain radius." }],
        icon: 'Altruist',
        types: ["Support"],
        options: [
            { name: "Altruist", description: "The percentage probability of the Altruist appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Revive Duration", description: "The time it takes for the Altruist to revive all dead bodies", type: "Time", default: "5s", range: "N/A" },
            { name: "Revive Uses", description: "The number of times the Revive ability can be used", type: "Number", default: "3", range: "N/A" },
            { name: "Revive Radius", description: "How wide the revive radius is", type: "Multiplier", default: "1x", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Cleric", team: "Crewmate",
        description: "The Cleric is a Crewmate that can barrier or cleanse other players. When a player is barriered they cannot be killed for a set duration. When a player is cleansed all negative effects are removed, however, not all effects are removed instantly, some are instead removed at the beginning of the following meeting.",
        abilities: [
            { name: "Barrier", icon: 'BarrierButton.png', description: "Barriers players, making them immune to kills for a duration." },
            { name: "Cleanse", icon: 'CleanseButton.png', description: "Removes negative effects from players." }
        ],
        icon: 'Cleric',
        types: ["Support"],
        options: [
            { name: "Cleric", description: "The percentage probability of the Cleric appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Barrier Cooldown", description: "The cooldown of the Cleric's Barrier and Cleanse buttons", type: "Time", default: "25s", range: "N/A" },
            { name: "Show Barriered Player", description: "Who should be able to see who is Barriered", type: "Self / Cleric / Self + Cleric", default: "Cleric", range: "N/A" },
            { name: "Cleric Gets Attack Notification", description: "Whether the Cleric knows when the barriered player is attacked", type: "Toggle", default: "True", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Mirrorcaster", team: "Crewmate",
        description: "The Mirrorcaster is a Crewmate Protective role that can cast a Magic Mirror on a player to protect them. If attacked directly, the Mirrorcaster can then unleash onto another player.",
        abilities: [
            { name: "Magic Mirror", icon: 'MagicMirrorButton.png', description: "Protects the player from one direct attack.(It looks like Medic Shield)" },
            { name: "Unleash", icon: 'UnleashButton.png', description: "Allows you to use the direct attack absorbed from the magic mirror on anyone." }
        ],
        icon: 'Mirrorcaster',
        types: ["Support"],
        options: [
            { name: "Who Gets Notification", description: "Who gets notification", type: " Self / Mirrorcaster / Self + Mirrorcaster", default: "Mirrorcaster", range: "N/A" },
            { name: "Mirror Cooldown", description: "The cooldown of the Mirrorcaster's Magic Mirror and Unleash buttons", type: "Time", default: "0", range: "0-60" },
            { name: "Mirror Duration", description: "How long Magic Mirror lasts for", type: "Time", default: "30", range: "0-60" },
            { name: "Know Attack Type", description: "Whether the Mirrorcaster knows what kind of attack was used", type: "Boolean", default: "True", range: "True - False" },
            { name: "MultiUnleash", description: "Whether the Mirrorcaster can unleash multiple attacks at one time", type: "Boolean", default: "false", range: "True - False" },
            { name: "Max Mirrors", description: "How many Magic Mirrors the Mirrorcaster has", type: "Integer", default: "5", range: "0-15" }
        ]
    },
    {
        category: "Role", name: "Oracle", team: "Crewmate",
        description: "The Oracle is a Crewmate that can get another player to confess information to them. The Oracle has 2 abilities. The first, confess, makes a player confess saying that one of two players is good and will reveal their alignment when the Oracle dies. The second, bless, makes someone immune to dying during a meeting.",
        abilities: [
            { name: "Confess", icon: 'ConfessButton.png', description: "Makes a player confess information, revealing alignments upon Oracle's death." },
            { name: "Bless", icon: 'BlessButton.png', description: "Grants immunity from dying during a meeting." }
        ],
        icon: 'Oracle',
        types: ["Detection", "Support"],
        options: [
            { name: "Oracle", description: "The percentage probability of the Oracle appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Confess Cooldown", description: "The Cooldown of the Oracle's Confess button", type: "Time", default: "10s", range: "N/A" },
            { name: "Initial Bless Cooldown", description: "The Initial Cooldown of the Oracle's Bless button", type: "Time", default: "10s", range: "N/A" },
            { name: "Reveal Accuracy", description: "The percentage probability of the Oracle's confessed player telling the truth", type: "Percentage", default: "80%", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Warden", team: "Crewmate",
        description: "The Warden is a Crewmate that can fortify other players. Fortified players cannot be interacted with. If someone tries to interact with or assassinate a fortified player, Both the Warden and the interactor receive an alert.",
        abilities: [{ name: "Fortify", icon: 'FortifyButton.png', description: "Fortifies players, making them immune to interactions and assassinations." }],
        icon: 'Warden',
        types: ["Support"],
        options: [
            { name: "Warden", description: "The percentage probability of the Warden appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Show Fortified Player", description: "Who should be able to see who is Fortified", type: "Self / Warden / Self + Warden", default: "Warden", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Imitator", team: "Crewmate",
        description: "The Imitator is a Crewmate that can mimic dead crewamtes. During meetings the Imitator can select who they are going to imitate the following round from the dead. They can choose to use each dead players as many times as they wish.",
        abilities: [{ name: "Imitate", icon: 'ImitateSelect.png', description: "Mimics dead crewmates' roles during meetings." }],
        icon: 'Imitator',
        types: ["Utility", "Other"],
        options: [
            { name: "Imitator", description: "The percentage probability of the Imitator appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Imitator Can Become Mayor", description: "Whether the Imitator can permanently become the Mayor", type: "Toggle", default: "True", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Mayor", team: "Crewmate",
        description: "Once per game the Mayor can reveal themselves as the Mayor mid-meeting, once done so they gain an additional 2 votes.",
        abilities: [{ name: "Reveal", icon: 'RevealClean.png', description: "Reveals self as Mayor to gain additional votes." }],
        icon: 'Mayor',
        types: ["Utility"],
        options: [
            { name: "Mayor", description: "The percentage probability of the Mayor appearing", type: "Percentage", default: "0%", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Medium", team: "Crewmate",
        description: "The Medium is a Crewmate that can see ghosts. During each round the Medium has an ability called Mediate. If the Medium uses this ability and no one is dead, nothing will happen. However, if someone is dead, the Medium and the dead player will be able to see each other and communicate from beyond the grave!",
        abilities: [{ name: "Mediate", icon: 'MediateButton.png', description: "Communicates with dead players." }],
        icon: 'Medium',
        types: ["Utility", "Detection"],
        options: [
            { name: "Medium", description: "The percentage probability of the Medium appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Mediate Cooldown", description: "The cooldown of the Medium's Mediate button", type: "Time", default: "10s", range: "N/A" },
            { name: "Reveal Appearance of Mediate Target", description: "Whether the Ghosts will show as themselves, or camouflaged", type: "Toggle", default: "True", range: "N/A" },
            { name: "Reveal the Medium to the Mediate Target", description: "Whether the ghosts can see that the Medium is the Medium", type: "Toggle", default: "True", range: "N/A" },
            { name: "Who is Revealed", description: "Which players are revealed to the Medium", type: "Oldest Dead / Newest Dead / All Dead", default: "Oldest Dead", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Plumber", team: "Crewmate",
        description: "The Plumber is a Crewmate that maintains vent systems. The Plumber can either flush vents, ejecting all players currently in vents, or block a vent, placing a barricade on the vent preventing it's use.",
        abilities: [
            { name: "Flush", icon: 'FlushButton.png', description: "Ejects all players from vents." },
            { name: "Barricade", icon: 'BarricadeButton.png', description: "Blocks a vent with a barricade." }
        ],
        icon: 'Plumber',
        types: ["Utility", "Sabotage"],
        options: [
            { name: "Plumber", description: "The percentage probability of the Plumber appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Flush Cooldown", description: "The cooldown of the Plumber's Flush and Block buttons", type: "Time", default: "25s", range: "N/A" },
            { name: "Maximum Barricades", description: "The number of times the Plumber can block a vent", type: "Number", default: "5", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Politician", team: "Crewmate",
        description: "The Politician is a Crewmate that can campaign to other players. Once half or more of the Crewmates are campaigned to, the Politician can reveal themselves as the new Mayor. If less then half of the Crewmates have been campaigned to the reveal will fail and the Politician will be unable to campaign for 1 round.",
        abilities: [{ name: "Campaign", icon: 'CampaignButton.png', description: "Campaigns to other players to reveal as Mayor." }],
        icon: 'Politician',
        types: ["Utility"],
        options: [
            { name: "Politician", description: "The percentage probability of the Politician appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Campaign Cooldown", description: "The cooldown of the Politician's Campaign button", type: "Time", default: "25s", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Prosecutor", team: "Crewmate",
        description: "The Prosecutor has 2 abilities, one is the ability for them to see all the votes (non-anonymous voting), the other, once per game during a meeting the Prosecutor can prosecute someone, making all other votes redundant and having whoever the Prosecutor selected exiled that meeting.",
        abilities: [{ name: "Prosecute", icon: 'Prosecutor.png', description: "Can see all votes and can exile someone once per game." }],
        icon: 'Prosecutor',
        types: ["Utility", "Detection"],
        options: [
            { name: "Prosecutor", description: "The percentage probability of the Prosecutor appearing", type: "Percentage", default: "0%", range: "N/A" },
            { name: "Prosecutor Dies When They Exile A Crewmate", description: "Whether the Prosecutor also gets exiled when they exile a Crewmate", type: "Toggle", default: "False", range: "N/A" }
        ]
    },

    {
        category: "Role", name: "Amnesiac", team: "Neutral",
        description: "The Amnesiac is a Neutral role with no win condition.\nThey have zero tasks and are essentially roleless. However, they can remember a role by finding a dead player.\nOnce they remember their role, they go on to try win with their new win condition.",
        abilities: [{ name: "Remember", icon: 'RememberButton.png', description: "Remembers a role by finding a dead player." }],
        icon: 'Amnesiac',
        types: ["Information"],
        options: [
            { name: "Amnesiac", description: "The percentage probability of the Amnesiac appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Amnesiac Gets Arrows", description: "Whether the Amnesiac has arrows pointing to dead bodies", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Arrow Appear Delay", description: "The delay of the arrows appearing after the person died", type: "Time", "default": "5s", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Guardian Angel", team: "Neutral",
        description: "The Guardian Angel is a Neutral role which aligns with the faction of their target.\nTheir job is to protect their target at all costs.\nIf their target loses, they lose.",
        abilities: [{ name: "Protect", icon: 'ProtectButton.png', description: "Protects their target from being killed." }],
        icon: 'GuardianAngel',
        types: ["Protective"],
        options: [
            { name: "Guardian Angel", description: "The percentage probability of the Guardian Angel appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Protect Cooldown", description: "The cooldown of the Guardian Angel's Protect button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Protect Duration", description: "How long The Guardian Angel's Protect lasts", type: "Time", "default": "10s", range: "N/A" },
            { name: "Max Uses", description: "The amount of times the Protect ability can be used", type: "Number", "default": "5", range: "N/A" },
            { name: "Show Protected Player", description: "Who should be able to see who is Protected", type: "Self / GA / Self + GA", "default": "Self", range: "N/A" },
            { name: "Guardian Angel becomes on Target Dead", description: "Which role the Guardian Angel becomes when their target dies", type: "Crewmate / Amnesiac / Mercenary / Survivor / Jester", "default": "Survivor", range: "N/A" },
            { name: "Target Knows GA Exists", description: "Whether the GA's Target knows they have a GA", type: "Toggle", "default": "False", range: "N/A" },
            { name: "GA Knows Targets Role", description: "Whether the GA knows their target's role", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Odds Of Target Being Evil", description: "The chances of the Guardian Angel's target being evil", type: "Percentage", "default": "20%", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Mercenary", team: "Neutral",
        description: "The Mercenary is a Neutral role which can guard other players.\nGuarded players absorb abilities and convert it into currency. This currency can be used to bribe other players.\nIf a bribed player lives and goes onto win the game, the Mercenary does too.\nThe Mercenary does not need to survive themselves. They cannot win with Neutral Evils or Lovers.",
        abilities: [
            { name: "Bribe", icon: 'BribeButton.png', description: "Uses currency to bribe other players." },
            { name: "Guard", icon: 'GuardButton.png', description: "Guards players, converting absorbed abilities into currency." }
        ],
        icon: 'Mercenary',
        types: ["Utility", "Support"],
        options: [
            { name: "Mercenary", description: "The percentage probability of the Mercenary appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Guard Cooldown", description: "The cooldown of the Mercenary's Guard button", type: "Time", "default": "10s", range: "N/A" },
            { name: "Max Guards", description: "The maximum amount of Guards active at one time", type: "Number", default: "3", range: "N/A" },
            { name: "Gold To Bribe", description: "The amount of gold required to bribe a player", type: "Number", "default": "3", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Survivor", team: "Neutral",
        description: "The Survivor is a Neutral role which can win by simply surviving.\nHowever, if Lovers, or a Neutral Evil role wins the game, the Survivor loses.",
        abilities: [{ name: "Safeguard", icon: 'VestButton.png', description: "Activates a vest to protect against kills." }],
        icon: 'Survivor',
        types: ["Protective"],
        options: [
            { name: "Survivor", description: "The percentage probability of the Survivor appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Vest Cooldown", description: "The cooldown of the Survivor's Vest button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Vest Duration", description: "How long The Survivor's Vest lasts", type: "Time", "default": "10s", range: "N/A" },
            { name: "Max Uses", description: "The amount of times the Vest ability can be used", type: "Number", "default": "5", range: "N/A" },
            { name: "Survivor Scatter Mechanic", description: "Whether the Survivor needs to keep moving to avoid dying", type: "Toggle", "default": "True", range: "N/A" },
            { name: "Survivor Movement Timer", description: "How frequently the Survivor needs to move", type: "Time", "default": "25s", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Doomsayer", team: "Neutral",
        description: "The Doomsayer is a Neutral role with its own win condition.\nTheir goal is to assassinate 3 players to win. If there are only 2 other people alive, the Doomsayer only needs to assassinate the remainder of the players.\nThey have an additional observe ability that hints towards certain player's roles.",
        abilities: [
            { name: "Observe", icon: 'ObserveButton.png', description: "Observes players to gain hints about their roles." },
            { name: "Guess", icon: 'Guess.png', description: "Assassinate players by guessing their role." }
        ],
        icon: 'Doomsayer',
        types: ["Killing", "Information"],
        options: [
            { name: "Doomsayer", description: "The percentage probability of the Doomsayer appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Observe Cooldown", description: "The Cooldown of the Doomsayer's Observe button", type: "Time", "default": "10s", range: "N/A" },
            { name: "Doomsayer Guesses All At Once", description: "Whether the Doomsayer has to guess all 3 roles to win at once", type: "Toggle", "default": "True", range: "N/A" },
            { name: "(Experienced) Doomsayer Can't Observe", description: "The Doomsayer doesn't have the observe feature", type: "Toggle", "default": "False", range: "N/A" },
                       { name: "Doomsayer Win Ends Game", description: "Whether Doomsayer winning ends the game", type: "Toggle", "default": "True", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Executioner", team: "Neutral",
        description: "The Executioner is a Neutral role with its own win condition.\nTheir goal is to vote out a player, specified in the beginning of a game.\nIf that player gets voted out, they win the game.",
        abilities: [],
        icon: 'Executioner',
        types: ["Chaos", "Killing"],
        options: [
            { name: "Executioner", description: "The percentage probability of the Executioner appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Executioner becomes on Target Dead", description: "Which role the Executioner becomes when their target dies", type: "Crewmate / Amnesiac / Mercenary / Survivor / Jester", "default": "Jester", range: "N/A" },
            { name: "Executioner Can Button", description: "Whether the Executioner Can Press the Button", type: "Toggle", "default": "True", range: "N/A" },
            { name: "Executioner Win", description: "What happens when the Executioner wins", type: "Ends Game / Nothing / Torments", "default": "Ends Game", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Jester", team: "Neutral",
        description: "The Jester is a Neutral role with its own win condition.\nIf they are voted out after a meeting, the game finishes and they win.\nHowever, the Jester does not win if the Crewmates, Impostors or another Neutral role wins.",
        abilities: [], // No active ability as per description
        icon: 'Jester',
        types: ["Chaos", "Killing"],
        options: [
            { name: "Jester", description: "The percentage probability of the Jester appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Jester Can Button", description: "Whether the Jester Can Press the Button", type: "Toggle", "default": "True", range: "N/A" },
            { name: "Jester Can Vent", description: "Whether the Jester Can Vent", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Jester Has Impostor Vision", description: "Whether the Jester Has Impostor Vision", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Jester Scatter Mechanic", description: "Whether the Jester needs to keep moving to avoid dying", type: "Toggle", "default": "True", range: "N/A" },
            { name: "Jester Movement Timer", description: "How frequently the Jester needs to move", type: "Time", "default": "25s", range: "N/A" },
            { name: "Jester Win", description: "What happens when the Jester wins", type: "Ends Game / Nothing / Haunts", "default": "Ends Game", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Phantom", team: "Neutral",
        description: "The Phantom \nis a Neutral role with its own win condition. They become half-invisible when they die and has to complete all their tasks without getting caught.",
        abilities: [
            { name: "Spook", icon: 'Spook.png', description: "Kill one person of your choosing" },
        ],
        icon: 'Phantom',
        types: ["Stealth", "Utility"],
        options: [
            { name: "Phantom", description: "The percentage probability of the Phantom appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "When Phantom Can Be Clicked", description: "The amount \nof tasks remaining when the Phantom Can Be Clicked", type: "Number", "default": "5", range: "N/A" },
            { name: "Phantom Win Ends Game", description: "Whether Phantom winning ends the game", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Inquisitor", team: "Neutral",
        description: "The Inquisitor is a Neutral Evil role that wins if their targets (Heretics) die.\nThe only information provided is their roles, and it\'s up to the Inquisitor to identify those players (marked with a dark pink-ish $ to the dead) and get them killed by any means neccesary.",
        abilities: [
            { name: "Inquire", icon: 'InquireButton.png', description: "Inquires to identify targets (Heretics)." },
            { name: "Vanquish", icon: 'InquisKillButton.png', description: "Eliminates identified targets." }
        ],
        icon: 'Inquisitor',
        types: ["Killing", "Information"],
        options: [
            { name: "Inquisitor", description: "The percentage probability of the Inquisitor appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Soul Collector", team: "Neutral",
        description: "The Soul Collector is a Neutral role with its own win condition.\nThe Soul Collector kills be reaping players, reaped players do not leave behind a dead body, instead they leave a soul.\nThe Soul Collector needs to be the last killer alive to win the game.",
        abilities: [{ name: "Reap", icon: 'ReapButton.png', description: "Reaps players, leaving behind a soul instead of a body." }],
        icon: 'SoulCollector',
        types: ["Killing", "Utility"],
        options: [
            { name: "Soul Collector", description: "The percentage probability of the Soul Collector appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Reap Cooldown", description: "The Cooldown of the Soul Collector's Reap button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Soul Collector can Vent", description: "Whether the Soul Collector can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Arsonist", team: "Neutral",
        description: "The Arsonist is a Neutral role with its own win condition.\nThey have two abilities, one is to douse other players with gasoline.\nThe other is to ignite all doused players near them.\nThe Arsonist needs to be the last killer alive to win the game.",
        abilities: [
            { name: "Douse", icon: 'DouseButton.png', description: "Douses players with gasoline." },
            { name: "Ignite", icon: 'IgniteButton.png', description: "Ignites all doused players nearby." }
        ],
        icon: 'Arsonist',
        types: ["Killing"],
        options: [
            { name: "Arsonist", description: "The percentage probability of the Arsonist appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Douse Cooldown", description: "The cooldown of the Arsonist's Douse button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Ignite Radius", description: "How wide the ignite radius is", type: "Multiplier", "default": "0.25x", range: "N/A" },
            { name: "Arsonist can Vent", description: "Whether the Arsonist can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Juggernaut", team: "Neutral",
        description: "The Juggernaut is a Neutral role \nwith its own win condition. The Juggernaut\'s special ability is that their kill cooldown reduces with each kill.\nThis means in theory the Juggernaut can have a 0 second kill cooldown!\nThe Juggernaut needs to be the last killer alive to win the game.",
        abilities: [{ name: "Kill", icon: 'JuggKillButton.png', description: "Kills with a cooldown that reduces with each kill." }],
        icon: 'Juggernaut',
        types: ["Killing"],
        options: [
            { name: "Juggernaut", description: "The percentage probability of the Juggernaut appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Juggernaut Kill Cooldown", description: "The initial cooldown of the Juggernaut's Kill button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Reduced Kill Cooldown Per Kill", description: "The amount of time removed from the Juggernaut's Kill Cooldown Per Kill", type: "Time", "default": "5s", range: "N/A" },
            { name: "Juggernaut can Vent", description: "Whether the Juggernaut can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Plaguebearer", team: "Neutral",
        description: "The Plaguebearer is a Neutral role with its own win condition, as well as an ability to transform into another role.\nThe Plaguebearer has one ability, which allows them to infect other players.\nOnce infected, the infected player can go and infect other players via interacting with them.\nOnce all players are infected, the Plaguebearer becomes Pestilence. The Pestilence is a unkillable force which can only be killed by being voted out, even their lover dying won't kill them.\nThe Plaguebearer or Pestilence needs to be the last killer alive to win the game.",
        abilities: [{ name: "Infect", icon: 'InfectButton.png', description: "Infects other players, spreading the plague." }],
        icon: 'Plaguebearer',
        types: ["Converting", "Killing"],
        options: [
            { name: "Plaguebearer", description: "The percentage probability of the Plaguebearer appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Infect Cooldown", description: "The cooldown of the Plaguebearer's Infect button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Pestilence Kill Cooldown", description: "The cooldown of the Pestilence's Kill button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Pestilence can Vent", description: "Whether the Pestilence can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Pestilence", team: "Neutral",
        description: "The Pestilence is a \nNeutral role with its own win condition. They can only be killed by being voted out, even their lover dying won't kill them.",
        abilities: [{ name: "Kill", icon: 'PestKillButton.png', description: "Kills players, cannot be killed except by voting." }],
        icon: 'Pestilence',
        types: ["Killing", "Defense"],
        options: [
            { name: "Pestilence", description: "The percentage probability of the Pestilence appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Glitch", team: "Neutral",
        description: "The Glitch is a Neutral role with its own win condition.\nThe Glitch's aim is to kill everyone and be the last person standing.\nThe Glitch can Hack players, resulting in them being unable to report bodies and use abilities.\nHacking prevents the hacked player from doing anything but walk around the map.\nThe Glitch can Mimic someone, which results in them looking exactly like the other person.",
        abilities: [
            { name: "Kill", icon: 'GlitchKillButton.png', description: "Eliminates other players." },
            { name: "Hack", icon: 'HackButton.png', description: "Disables players' ability to report or use abilities." },
            { name: "Mimic", icon: 'MimicButton.png', description: "Mimics another player's appearance." }
        ],
        icon: 'Glitch',
        types: ["Killing", "Sabotage", "Deception"],
        options: [
            { name: "The Glitch", description: "The percentage probability of The Glitch appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Mimic Cooldown", description: "The cooldown of The Glitch's Mimic button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Mimic Duration", description: "How long The Glitch can Mimic a player", type: "Time", "default": "10s", range: "N/A" },
            { name: "Hack Cooldown", description: "The cooldown of The Glitch's Hack button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Hack Duration", description: "How long The Glitch can Hack a player", type: "Time", "default": "10s", range: "N/A" },
            { name: "Glitch Kill Cooldown", description: "The cooldown of the Glitch's Kill button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Glitch can Vent", description: "Whether the Glitch can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Vampire", team: "Neutral",
        description: "The Vampire is a Neutral role with its own \nwin condition. The Vampire can convert or kill other players by biting them.\nIf the bitten player was a Crewmate they will turn into a Vampire (unless there are 2 Vampires alive) Else they will kill the bitten player.",
        abilities: [{ name: "Bite", icon: 'BiteButton.png', description: "Converts or kills players by biting them." }],
        icon: 'Vampire',
        types: ["Converting", "Killing"],
        options: [
            { name: "Vampire", description: "The percentage probability of the Vampire appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Bite Cooldown", description: "The cooldown of the Vampire's \nBite button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Vampire Has Impostor Vision", description: "Whether the Vampire Has Impostor Vision", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Vampire Can Vent", description: "Whether the Vampire Can Vent", type: "Toggle", "default": "False", range: "N/A" },
            { name: "New Vampire Can Assassinated", description: "Whether the new Vampire can assassinate", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Maximum Vampires Per Game", description: "The maximum amount of players that can be Vampires", type: "Number", "default": "2", range: "N/A" },
            { name: "Can Convert Neutral Benign Roles", description: "Whether Neutral Benign Roles can be turned into Vampires", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Can Convert Neutral Evil Roles", description: "Whether Neutral Evil Roles can be turned into Vampires", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Werewolf", team: "Neutral",
        description: "The Werewolf is a Neutral role with its own win condition.\nAlthough the Werewolf has a kill button, they can't use it unless they are Rampaged.\nOnce the Werewolf rampages they gain Impostor vision and the ability to kill.\nHowever, unlike most killers their kill cooldown is really short.\nThe Werewolf needs to be the last killer alive to win the game.",
        abilities: [
            { name: "Rampage", icon: 'RampageButton.png', description: "Activates rampage mode, gaining Impostor vision and kill ability." },
            { name: "Kill", icon: 'WolfKillButton.png', description: "Kills with a short cooldown while rampaging." }
        ],
        icon: 'Werewolf',
        types: ["Killing", "Movement"],
        options: [
            { name: "Werewolf", description: "The percentage probability of the Werewolf appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Rampage Cooldown", description: "The cooldown of the Werewolf's Rampage button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Rampage Duration", description: "The duration of the Werewolf's Rampage", type: "Time", "default": "25s", range: "N/A" },
            { name: "Rampage Kill Cooldown", description: "The cooldown of the Werewolf's Kill button", type: "Time", "default": "10s", range: "N/A" },
            { name: "Werewolf can Vent when Rampaged", description: "Whether the Werewolf can Vent when Rampaged", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Eclipsal", team: "Impostor",
        description: "The Eclipsal is an Impostor that can blind other players.\nBlinded players have no vision and their report buttons do not light up (but can still be used).",
        abilities: [{ name: "Blind", icon: 'BlindButton.png', description: "Blinds other players, removing their vision." }],
        icon: 'Eclipsal',
        types: ["Sabotage"],
        options: [
            { name: "Eclipsal", description: "The percentage probability of the Eclipsal appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Blind Cooldown", description: "The cooldown of the Eclipsal's Blind button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Blind Duration", description: "How long the Blind lasts for", type: "Time", "default": "25s", range: "N/A" },
            { name: "Blind Radius", description: "How wide the blind radius is", type: "Multiplier", "default": "1x", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Escapist", team: "Impostor",
        description: "The Escapist is an \nImpostor that can teleport to a different location. Once per round the Escapist can Mark a location which they can then escape to later in the round.",
        abilities: [
            { name: "Mark", icon: 'MarkButton.png', description: "Marks a location" },
            { name: "Recall", icon: 'RecallButton.png', description: "Teleports back to it." }
            ],
        icon: 'Escapist',
        types: ["Movement"],
        options: [
            { name: "Escapist", description: "The percentage probability of the Escapist appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Recall Cooldown", description: "The cooldown of the \nEscapist\'s Recall button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Escapist can Vent", description: "Whether the Escapist can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Grenadier", team: "Impostor",
        description: "The Grenadier is an Impostor that can throw smoke grenades. During the game, the Grenadier has the option to throw down a smoke grenade which blinds Crewmates so they can't see. However, a sabotage and a smoke grenade can not be active at the same time.",
        abilities: [{ name: "Flash", icon: 'FlashButton.png', description: "Throws smoke grenades to blind Crewmates." }],
        icon: 'Grenadier',
        types: ["Kill"],
        options: [
            { name: "Grenadier", description: "The percentage probability of the Grenadier appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Flash Grenade Cooldown", description: "The cooldown of the Grenadier's Flash button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Flash Grenade Duration", description: "How long the Flash Grenade lasts for", type: "Time", "default": "10s", range: "N/A" },
            { name: "Flash Radius", description: "How wide the flash radius is", type: "Multiplier", "default": "1x", range: "N/A" },
            { name: "Grenadier can Vent", description: "Whether the Grenadier can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Morphling", team: "Impostor",
        description: "The Morphling is an Impostor that can Morph into another player. At the beginning of the game and after every meeting, they can choose someone to Sample. They can then Morph into that person at any time for a limited amount of time.",
        abilities: [
            { name: "Sample", icon: 'SampleButton.png', description: "Samples a player to morph into them later." },
            { name: "Morph", icon: 'MorphButton.png', description: "Temporarily morphs into a sampled player." }
        ],
        icon: 'Morphling',
        types: ["Utility", "Sabotage"],
        options: [
            { name: "Morphling", description: "The percentage probability of the Morphling appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Morph Cooldown", description: "The cooldown of the Morphling's Morph button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Morph Duration", description: "How long the Morph lasts for", type: "Time", "default": "10s", range: "N/A" },
            { name: "Morphling can Vent", description: "Whether the Morphling can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Ambassador", team: "Impostor",
        description: "The Ambassador is an Impostor Power role that can retrain impostors into other impostor roles of the same caliber after a set amount of kills. Impostor Concealing/Support Roles can become other Concealing and Support roles, while Impostor Killing and Power roles can be any Non-Power roles.",
        abilities: [
            { name: "Retrain", icon: 'RetrainClean.png', description: "Retrains you or your imposter partner into a new role" },
        ],
        icon: 'Ambassador',
        types: ["Utility", "Sabotage"],
        options: [
            { name: "Morphling", description: "The percentage probability of the Morphling appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Morph Cooldown", description: "The cooldown of the Morphling's Morph button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Morph Duration", description: "How long the Morph lasts for", type: "Time", "default": "10s", range: "N/A" },
            { name: "Morphling can Vent", description: "Whether the Morphling can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Ambusher", team: "Impostor",
        description: "The Ambusher is an Impostor Killing role that can pursue a player, getting an arrow to them. They may ambush the closest player next to them. If they manage to kill the player, they will drag their body into the shadows, teleporting back with the Ambusher.",
        abilities: [
            { name: "Ambush", icon: 'AmbushButton.png', description: "Teleport to kill the person then teleport back to where u were originally along with dragging the body with you" },
        ],
        icon: 'Ambusher',
        types: ["Utility", "Sabotage"],
        options: [
            { name: "Morphling", description: "The percentage probability of the Morphling appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Morph Cooldown", description: "The cooldown of the Morphling's Morph button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Morph Duration", description: "How long the Morph lasts for", type: "Time", "default": "10s", range: "N/A" },
            { name: "Morphling can Vent", description: "Whether the Morphling can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Swooper", team: "Impostor",
        description: "The Swooper is an Impostor that can temporarily turn invisible.",
        abilities: [{ name: "Swoop", icon: 'SwoopButton.png', description: "Temporarily turns invisible." }],
        icon: 'Swooper',
        types: ["Utility"],
        options: [
            { name: "Swooper", description: "The percentage probability of the Swooper appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Swooper Cooldown", description: "The cooldown of the Swooper's Swoop button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Swooper Duration", description: "How long the Swooping lasts for", type: "Time", "default": "10s", range: "N/A" },
            { name: "Swooper can Vent", description: "Whether the Swooper can Vent", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Venerer", team: "Impostor",
        description: "The Venerer is an Impostor that gains abilities through killing. After their first kill, the Venerer can camouflage themself. After their second kill, the Venerer can sprint. After their third kill, every other player is slowed while their ability is activated. All abilities are activated by the one button and have the same duration.",
        abilities: [
            { name: "Camouflage", icon: 'CamouflageButton.png', description: "Camouflages self after first kill." },
            { name: "Sprint", icon: 'CamoSprintButton.png', description: "Sprints after second kill." },
            { name: "Freeze", icon: 'CamoSprintFreezeButton.png', description: "Slows other players after third kill." }
        ],
        icon: 'Venerer',
        types: ["Sabotage", "Utility"],
        options: [
            { name: "Venerer", description: "The percentage probability of the Venerer appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Ability Cooldown", description: "The cooldown of the Venerer's Ability button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Ability Duration", description: "How long the Venerer's ability lasts for", type: "Time", "default": "10s", range: "N/A" },
            { name: "Sprint Speed", description: "How fast the speed increase of the Venerer is when sprinting", type: "Multiplier", "default": "1.25x", range: "N/A" },
            { name: "Min Freeze Speed", description: "How slow the minimum speed is when the Venerer's ability is active", type: "Multiplier", "default": "0.25x", range: "N/A" },
            { name: "Freeze Radius", description: "How wide the freeze radius is", type: "Multiplier", "default": "1x", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Bomber", team: "Impostor",
        description: "The Bomber is an Impostor who has the ability to plant bombs instead of kill. After a bomb is planted, the bomb will detonate a fixed time period as per settings. Once the bomb detonates it will kill all Crewmates (and Impostors!) inside the radius.",
        abilities: [{ name: "Plant", icon: 'DetonatingButton.png', description: "Plants bombs that detonate and kill players within a radius." }],
        icon: 'Bomber',
        types: ["Kill", "Sabotage"],
        options: [
            { name: "Bomber", description: "The percentage probability of the Bomber appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Detonate Delay", description: "The delay of the detonation after bomb has been planted", type: "Time", "default": "5s", range: "N/A" },
            { name: "Max Kills In Detonation", description: "Maximum number of kills in the detonation", type: "Time", "default": "5s", range: "N/A" },
            { name: "Detonate Radius", description: "How wide the detonate radius is", type: "Multiplier", "default": "0.25x", range: "N/A" },
            { name: "Bomber can Vent", description: "Whether the Bomber can Vent", type: "Toggle", "default": "False", range: "N/A" },
            { name: "All Imps See Bomb", description: "Whether all the Impostors see the Bomber's bombs", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Scavenger", team: "Impostor",
        description: "The Scavenger is an Impostor who hunts down prey. With each successful hunt the Scavenger has a shortened kill cooldown. On an incorrect kill the Scavenger has a significantly increased kill cooldown.",
        abilities: [],
        icon: 'Scavenger',
        types: ["Utility", "Sabotage"],
        options: [
            { name: "Scavenger", description: "The percentage probability of the Scavenger appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Scavenge Duration", description: "How long the Scavenger's scavenge lasts for", type: "Time", "default": "25s", range: "N/A" },
            { name: "Scavenge Duration Increase Per Kill", description: "How much time the Scavenge duration increases on a correct kill", type: "Time", "default": "10s", range: "N/A" },
            { name: "Scavenge Kill Cooldown On Correct Kill", description: "The kill cooldown the Scavenger has on a correct kill", type: "Time", "default": "10s", range: "N/A" },
            { name: "Kill Cooldown Multiplier On Incorrect Kill", description: "The increased time the kill cooldown has on an incorrect kill", type: "Multiplier", "default": "3x", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Traitor", team: "Impostor",
        description: "If all Impostors die before a certain point in the game, a random Crewmate is selected to become the Traitor. The Traitor has no additional abilities and their job is simply to avenge the dead Impostors. Once this player has turned into the Traitor their alliance sits with the Impostors. The Traitor is offered a choice of up to 3 Impostor roles when they initially change roles.",
        abilities: [{ name: "Select", icon: 'TraitorSelect.png', description: "Selects an Impostor role to take on if all Impostors die." }],
        icon: 'Traitor',
        types: ["Other"],
        options: [
            { name: "Traitor", description: "The percentage probability of the Traitor appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Minimum People Alive When Traitor Can Spawn", description: "The minimum number of people alive when a Traitor can spawn", type: "Number", "default": "5", range: "N/A" },
            { name: "Traitor Won't Spawn if Neutral Killing are Alive", description: "Whether the Traitor won't spawn if any Neutral Killing roles are alive", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Warlock", team: "Impostor",
        description: "The Warlock is an Impostor that can charge up their kill button. Once activated the Warlock can use their kill button infinitely until they run out of charge. However, they do not need to fully charge their kill button to use it.",
        abilities: [{ name: "Charge", icon: 'Warlock.png', description: "Charges kill button for infinite kills until charge runs out." }],
        icon: 'Warlock',
        types: ["Sabotage"],
        options: [
            { name: "Warlock", description: "The percentage probability of the Warlock appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Time It Takes To Fully Charge", description: "The time it takes to fully charge the Warlock's Kill Button", type: "Time", "default": "25s", range: "N/A" },
            { name: "Time It Takes To Use Full Charge", description: "The maximum duration a charge of the Warlock's Kill Button lasts", type: "Time", "default": "1s", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Blackmailer", team: "Impostor",
        description: "The Blackmailer is an Impostor that can silence people in meetings. During each round, the Blackmailer can go up to someone and blackmail them. This prevents the blackmailed person from speaking and possibly voting during the next meeting.",
        abilities: [{ name: "Blackmail", icon: 'BlackmailButton.png', description: "Silences people in meetings, preventing them from speaking and voting." }],
        icon: 'Blackmailer',
        types: ["Sabotage"],
        options: [
            { name: "Blackmailer", description: "The percentage probability of the Blackmailer appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Initial Blackmail Cooldown", description: "The initial cooldown of the Blackmailer's Blackmail button", type: "Time", "default": "10s", range: "N/A" },
            { name: "Only Target Sees Blackmail", description: "If enabled, only the blackmailed player (and the Blackmailer) will see that the player can't speak", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Maximum People Alive Where Blackmailed Can Vote", description: "The maximum number of players alive to allow the blackmailed player to vote", type: "Number", "default": "5", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Hypnotist", team: "Impostor",
        description: "The Hypnotist is an Impostor that can hypnotize people. Once enough people are hypnotized, the Hypnotist can release Mass Hysteria. With Mass Hysteria released, all hypnotized players see all other players as either themselves, camouflaged or invisible. Once the Hypnotist dies Mass Hysteria is removed and people can see everyone normally again.",
        abilities: [
            { name: "Hypnotize", icon: 'HypnotiseButton.png', description: "Hypnotizes people to prepare for Mass Hysteria." },
            { name: "Mass Hysteria", icon: 'HysteriaClean.png', description: "Releases Mass Hysteria, altering hypnotized players' vision." }
        ],
        icon: 'Hypnotist',
        types: ["Sabotage"],
        options: [
            { name: "Hypnotist", description: "The percentage probability of the Hypnotist appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Hypnotize Cooldown", description: "The cooldown of the Hypnotist's Hypnotize button", type: "Time", "default": "25s", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Janitor", team: "Impostor",
        description: "The Janitor is an Impostor that can clean up bodies. Both their Kill and Clean ability have a shared cooldown, meaning they have to choose which one they want to use.",
        abilities: [{ name: "Clean", icon: 'CleanButton.png', description: "Cleans up bodies." }],
        icon: 'Janitor',
        types: ["Utility"],
        options: [
            { name: "Janitor", description: "The percentage probability of the Janitor appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Miner", team: "Impostor",
        description: "The Miner is an Impostor that can create new vents. These vents only connect to each other, forming a new passway.",
        abilities: [{ name: "Mine", icon: 'MineButton.png', description: "Creates new interconnected vents." }],
        icon: 'Miner',
        types: ["Utility"],
        options: [
            { name: "Miner", description: "The percentage probability of the Miner appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Role", name: "Undertaker", team: "Impostor",
        description: "The Undertaker is an Impostor that can drag and drop bodies.",
        abilities: [{ name: "Drag", icon: 'DragButton.png', description: "Drags and drops bodies." }],
        icon: 'Undertaker',
        types: ["Utility"],
        options: [
            { name: "Undertaker", description: "The percentage probability of the Undertaker appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Undertaker Drag Cooldown", description: "The cooldown of the Undertaker Drag ability", type: "Time", "default": "25s", range: "N/A" },
            { name: "Undertaker Speed While Dragging", description: "How fast the Undertaker moves while dragging a body in comparison to normal", type: "Multiplier", "default": "0.75x", range: "N/A" },
            { name: "Undertaker can Vent", description: "Whether the Undertaker can Vent", type: "Toggle", "default": "False", range: "N/A" },
            { name: "Undertaker can Vent while Dragging", description: "Whether the Undertaker can Vent when they are Dragging a Body", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    // Crewmate Modifiers
    {
        category: "Modifier", name: "Aftermath", team: "Crewmate Modifier",
        description: "Killing the Aftermath forces their killer to use their ability (if they have one and it's not in use).",
        abilities: [],
        icon: 'Aftermath',
        types: ["Passive", "Death Trigger"],
        options: [
            { name: "Aftermath", description: "The percentage probability of the Aftermath appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Bait", team: "Crewmate Modifier",
        description: "Killing the Bait makes the killer auto self-report.",
        abilities: [],
        icon: 'Bait',
        types: ["Passive", "Death Trigger"],
        options: [
            { name: "Bait", description: "The percentage probability of the Bait appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Bait Minimum Delay", description: "The minimum time the killer of the Bait reports the body", type: "Time", "default": "0s", range: "0s - 10s" },
            { name: "Bait Maximum Delay", description: "The maximum time the killer of the Bait reports the body", type: "Time", "default": "1s", range: "0s - 10s" }
        ]
    },
    {
        category: "Modifier", name: "Celebrity", team: "Crewmate Modifier",
        description: "The Celebrity announces how, when and where they died the meeting after they die.",
        abilities: [],
        icon: 'Celebrity',
        types: ["Passive", "Death Trigger", "Information"],
        options: [
            { name: "Celebrity", description: "The percentage probability of the Celebrity appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Diseased", team: "Crewmate Modifier",
        description: "Killing the Diseased increases the killer's kill cooldown.",
        abilities: [],
        icon: 'Diseased',
        types: ["Passive", "Death Trigger", "Debuff"],
        options: [
            { name: "Diseased", description: "The percentage probability of the Diseased appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Kill Multiplier", description: "How much the Kill Cooldown of the Impostor is increased by", type: "Multiplier", "default": "3x", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Frosty", team: "Crewmate Modifier",
        description: "Killing the Frosty slows the killer for a short duration.",
        abilities: [],
        icon: 'Frosty',
        types: ["Passive", "Death Trigger", "Debuff"],
        options: [
            { name: "Frosty", description: "The percentage probability of the Frosty appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Chill Duration", description: "The duration of the chill after killing the Frosty", type: "Time", "default": "10s", range: "N/A" },
            { name: "Chill Start Speed", description: "The start speed of the chill after killing the Frosty", type: "Multiplier", "default": "0.75x", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Multitasker", team: "Crewmate Modifier",
        description: "The Multitasker's tasks are transparent.",
        abilities: [],
        icon: 'Multitasker',
        types: ["Passive", "Utility"],
        options: [
            { name: "Multitasker", description: "The percentage probability of the Multitasker appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Taskmaster", team: "Crewmate Modifier",
        description: "The Taskmaster completes a random task on the completion of each meeting.",
        abilities: [],
        icon: 'Taskmaster',
        types: ["Passive", "Utility"],
        options: [
            { name: "Taskmaster", description: "The percentage probability of the Taskmaster appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Torch", team: "Crewmate Modifier",
        description: "The Torch's vision doesn't get reduced when the lights are sabotaged.",
        abilities: [],
        icon: 'Torch',
        types: ["Passive", "Utility"],
        options: [
            { name: "Torch", description: "The percentage probability of the Torch appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    // Crewmate Postmortem Modifiers
    {
        category: "Modifier", name: "Noisemaker", team: "Crewmate Modifier",
        description: "After your death, you will show a red body indicator to everyone on the map.",
        abilities: [],
        icon: 'Noisemaker',
        types: ["Passive", "Postmortem", "Detection"],
        options: [
            { name: "Noisemaker", description: "The percentage probability of the Noisemaker appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Operative", team: "Crewmate Modifier",
        description: "Use cameras at anytime, anywhere with a limited battery charge.",
        abilities: [{ name: "Portable Cameras", icon: 'CamButton.png', description: "Accesses cameras anytime, anywhere with limited battery." }],
        icon: 'Operative',
        types: ["Active", "Postmortem", "Utility"],
        options: [
            { name: "Operative", description: "The percentage probability of the Operative appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Rotting", team: "Crewmate Modifier",
        description: "After a set amount of time, your body will rot away, preventing you from being reported",
        abilities: [],
        icon: 'Rotting',
        types: ["Passive", "Postmortem", "Utility"],
        options: [
            { name: "Rotting", description: "The percentage probability of the Rotting appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Scientist", team: "Crewmate Modifier",
        description: "Access Vitals anytime, anywhere with a limited battery charge.",
        abilities: [{ name: "Portable Vitals", icon: 'VitalsButton.png', description: "Accesses vitals anytime, anywhere with limited battery." }],
        icon: 'Scientist',
        types: ["Active", "Postmortem", "Utility"],
        options: [
            { name: "Scientist", description: "The percentage probability of the Scientist appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Scout", team: "Crewmate Modifier",
        description: "While you can see twice as far as a regular Crewmate, your vision falters when lights are off.",
        abilities: [],
        icon: 'Scout',
        types: ["Passive", "Postmortem", "Detection"],
        options: [
            { name: "Scout", description: "The percentage probability of the Scout appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    // Global Modifiers
    {
        category: "Modifier", name: "Button Barry", team: "Global Modifier",
        description: "Button Barry has the ability to call a meeting from anywhere on the map, even during sabotages. They have the same amount of meetings as a regular player.",
        abilities: [{ name: "Portable Button", icon: 'BarryButton.png', description: "Calls a meeting from anywhere, even during sabotages." }],
        icon: 'ButtonBarry',
        types: ["Passive", "Utility"],
        options: [
            { name: "Button Barry", description: "The percentage probability of Button Barry appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Flash", team: "Global Modifier",
        description: "The Flash travels at a faster speed in comparison to a normal player.",
        abilities: [],
        icon: 'Flash',
        types: ["Passive", "Buff"],
        options: [
            { name: "Flash", description: "The percentage probability of the Flash appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Speed", description: "How fast the Flash moves in comparison to normal", type: "Multiplier", "default": "1.25x", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Giant", team: "Global Modifier",
        description: "The Giant is a gigantic Crewmate, that has a decreased walk speed.",
        abilities: [],
        icon: 'Giant',
        types: ["Passive", "Buff"],
        options: [
            { name: "Giant", description: "The percentage probability of the Giant appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Speed", description: "How fast the Giant moves in comparison to normal", type: "Multiplier", "default": "0.75x", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Immovable", team: "Global Modifier",
        description: "The Immovable cannot be moved by meetings, transports and disperse.",
        abilities: [],
        icon: 'Immovable',
        types: ["Passive", "Defense"],
        options: [
            { name: "Immovable", description: "The percentage probability of the Immovable appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Lovers", team: "Global Modifier",
        description: "The Lovers are two players who are linked together. These two players get picked randomly between Crewmates and Impostors. They gain the primary objective to stay alive together. If they are both among the last 3 players, they win. In order to do so, they gain access to a private chat, only visible by them in between meetings. However, they can also win with their respective team, hence why the Lovers do not know the role of the other lover.",
        abilities: [],
        icon: 'Lover',
        types: ["Passive", "Social", "Win Condition"],
        options: [
            { name: "Lovers", description: "The percentage probability of the Lovers appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Both Lovers Die", description: "Whether the other Lover automatically dies if the other does", type: "Toggle", "default": "True", range: "N/A" },
            { name: "Loving Impostor Probability", description: "The chances of one lover being an Impostor", type: "Percentage", "default": "20%", range: "N/A" },
            { name: "Neutral Roles Can Be Lovers", description: "Whether a Lover can be a Neutral Role", type: "Toggle", "default": "True", range: "N/A" },
            { name: "Impostor Lover Can Kill Teammate", description: "Whether an Impostor Lover can kill another Impostor", type: "Toggle", "default": "False", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Mini", team: "Global Modifier",
        description: "The Mini is a tiny Crewmate.",
        aabilities: [],
        icon: 'Mini',
        types: ["Passive", "Debuff"],
        options: [
            { name: "Mini", description: "The percentage probability of the Mini appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Radar", team: "Global Modifier",
        description: "The Radar is a Crewmate who knows where the closest player is to them.",
        abilities: [],
        icon: 'Radar',
        types: ["Passive", "Detection"],
        options: [
            { name: "Radar", description: "The percentage probability of the Radar appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Satellite", team: "Global Modifier",
        description: "The Satellite has a 1 time use ability to detect all dead bodies.",
        abilities: [{ name: "Detect", icon: 'BroadcastButton.png', description: "Detects all dead bodies once per game." }],
        icon: 'Satellite',
        types: ["Active", "Detection"],
        options: [
            { name: "Satellite", description: "The percentage probability of the Satellite appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Broadcast Duration", description: "The duration of the broadcast arrows", type: "Time", "default": "10s", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Shy", team: "Global Modifier",
        description: "The Shy becomes transparent when standing still for a short duration.",
        abilities: [],
        icon: 'Shy',
        types: ["Passive", "Utility"],
        options: [
            { name: "Shy", description: "The percentage probability of the Shy appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Transparency Delay", description: "The delay until the Shy starts turning transparent", type: "Time", "default": "5s", range: "N/A" },
            { name: "Turn Transparent Duration", description: "The duration of the Shy turning transparent", type: "Time", "default": "5s", range: "N/A" },
            { name: "Final Opacity", description: "The final opacity level of the Shy", type: "Percentage", "default": "20%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Sixth Sense", team: "Global Modifier",
        description: "The Sixth Sense is a Crewmate who can see who interacts with them.",
        abilities: [],
        icon: 'SixthSense',
        types: ["Passive", "Detection"],
        options: [
            { name: "Sixth Sense", description: "The percentage probability of the Sixth Sense appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Sleuth", team: "Global Modifier",
        description: "The Sleuth is a Crewmate who gains knowledge from reporting dead bodies. During meetings the Sleuth can see the roles of all players in which they've reported.",
        abilities: [],
        icon: 'Sleuth',
        types: ["Passive", "Detection"],
        options: [
            { name: "Sleuth", description: "The percentage probability of the Sleuth appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Tiebreaker", team: "Global Modifier",
        description: "If any vote is a draw, the Tiebreaker's vote will go through. If they voted another player, they will get voted out.",
        abilities: [],
        icon: 'Tiebreaker',
        types: ["Active", "Utility"],
        options: [
            { name: "Tiebreaker", description: "The percentage probability of the Tiebreaker appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    // Crewmate Alliance Modifiers
    {
        category: "Modifier", name: "Egotist", team: "Crewmate Alliance modifier",
        description: "As the Egotist, you can only win if Crewmates lose, but you can still win even in death. If no Crewmates remain after a meeting ends, you will leave in victory, but the game will continue. Egotist Snitch and Mayor also reveal themselves as evil to Neutrals and Impostors alike, and they do not get punished when killing Crewmates.",
        abilities: [],
        icon: 'Egotist',
        types: ["Passive", "Win Condition", "Information"],
        options: [
            { name: "Egotist", description: "The percentage probability of the Egotist appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    // Impostor Modifiers
    {
        category: "Modifier", name: "Disperser", team: "Impostor Modifier",
        description: "The Disperser is an Impostor who has a 1 time use ability to send all players to a random vent. This includes miner vents. Does not appear on Airship or Submerged.",
        abilities: [{ name: "Disperse", icon: 'DisperseButton.png', description: "Sends all players to a random vent (1-time use)." }],
        icon: 'Disperser',
        types: ["Active", "Sabotage"],
        options: [
            { name: "Disperser", description: "The percentage probability of the Disperser appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Double Shot", team: "Impostor/Neutral Modifier",
        description: "Double Shot is an Impostor who gets an extra life when assassinating. Once they use their life they are indicated with a red flash and can no longer guess the person who they guessed wrong for the remainder of that meeting.",
        abilities: [{ name: "Guess", icon: 'Guess.png', description: "Gets an extra life when assassinating." }],
        icon: 'DoubleShot',
        types: ["Passive", "Kill", "Defense"],
        options: [
            { name: "Double Shot", description: "The percentage probability of Double Shot appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Saboteur", team: "Impostor Modifier",
        description: "The Saboteur is an Impostor with a passive sabotage cooldown reduction.",
        abilities: [],
        icon: 'Saboteur',
        types: ["Passive", "Sabotage"],
        options: [
            { name: "Saboteur", description: "The percentage probability of the Saboteur appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Reduced Sabotage Bonus", description: "The amount of time removed from the Saboteur's sabotage cooldowns", type: "Time", "default": "10s", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Underdog", team: "Impostor Modifier",
        description: "The Underdog is an Impostor with a prolonged kill cooldown. When they are the only remaining Impostor, they will have their kill cooldown shortened.",
        abilities: [],
        icon: 'Underdog',
        types: ["Passive", "Kill", "Buff"],
        options: [
            { name: "Underdog", description: "The percentage probability of the Underdog appearing", type: "Percentage", "default": "0%", range: "N/A" },
            { name: "Kill Cooldown Bonus", description: "The amount of time added or removed from the Underdog's Kill Cooldown", type: "Time", "default": "5s", range: "N/A" },
            { name: "Increased Kill Cooldown", description: "Whether the Underdog's Kill Cooldown is Increased when 2+ Imps are alive", type: "Toggle", "default": "True", range: "N/A" }
        ]
    },
    // Impostor Postmortem Modifiers
    {
        category: "Modifier", name: "Telepath", team: "Impostor Modifier",
        description: "Know when your teammate kills (maybe where depending on settings), and depending on other settings, know when and/or where they die.",
        abilities: [],
        icon: 'Telepath',
        types: ["Passive", "Postmortem", "Information"],
        options: [
            { name: "Telepath", description: "The percentage probability of the Telepath appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    },
    {
        category: "Modifier", name: "Crewposter", team: "Impostor Modifier",
        description: "Betray the Crewmates by working for the imposters",
        abilities: [],
        icon: 'Telepath',
        types: ["Passive", "Alliance", "Information"],
        options: [
            { name: "Crewposter", description: "The percentage probability of the Crewposter appearing", type: "Percentage", "default": "0%", range: "N/A" }
        ]
    }
];

    function getRoleImageUrl(iconName) {
    // Make sure your role images are in the 'img/roles/' folder and named like 'Aurial.png'
    return `Media/${iconName}.png`;
}

/**
 * Generates the URL for a modifier icon.
 * Assumes modifier icons are named like 'Telepath.png' and located in 'img/modifiers/'.
 * @param {string} iconName - The base name of the modifier icon (e.g., 'Telepath').
 * @returns {string} The full URL to the modifier icon.
 */
function getModifierImageUrl(iconName) {
    // Make sure your modifier images are in the 'img/modifiers/' folder and named like 'Telepath.png'
    return `Media/${iconName}.png`;
}

    function findRoleData(roleName) {
        const normalizedRoleName = roleName.trim().toLowerCase();
        return allEntitiesData.find(entity => entity.name.toLowerCase() === normalizedRoleName);
    }

    // --- New State Variable to track the currently visible role for each player ---

// --- New Function: Get Consolidated Roles ---
/**
 * Finds the consolidated roles for a specific player name.
 */
function getConsolidatedRolesForPlayer(playerName) {
    // NOTE: This assumes 'consolidateRoles()' is defined elsewhere and works correctly.
    const consolidated = consolidateRoles(); 
    return consolidated.find(p => p.name.toLowerCase() === playerName.toLowerCase());
}

// --- New Function: Cycle Role Index ---
/**
 * Updates the visible role index for a player and re-renders the card.
 */
function cyclePlayerRole(playerName, direction) {
    const playerRolesData = getConsolidatedRolesForPlayer(playerName);
    if (!playerRolesData || playerRolesData.roles.length <= 1) return;

    const numRoles = playerRolesData.roles.length;
    let currentIndex = playerActiveRoleIndex[playerName] || 0;

    let newIndex = currentIndex + direction;

    // Handle wrapping (circular array)
    if (newIndex < 0) {
        newIndex = numRoles - 1;
    } else if (newIndex >= numRoles) {
        newIndex = 0;
    }

    playerActiveRoleIndex[playerName] = newIndex;
    
    // Find the old card and replace it with the new one
    const oldCard = rolesContentDiv.querySelector(`.role-card[data-player="${playerName}"]`);
    if (oldCard) {
        // Re-create the element using the new active role index
        const newCard = createRoleCardElement(playerRolesData); 
        rolesContentDiv.replaceChild(newCard, oldCard);
    }
}

    // --- Tab Management Functions ---
    function saveTabs() {
        localStorage.setItem('notesTabs', JSON.stringify(notesTabs));
        localStorage.setItem('roleCards', JSON.stringify(roleCards));
    }

    function createTabButton(tabName) {
        const button = document.createElement('button');
        button.classList.add('tab-button');
        button.textContent = tabName;
        button.dataset.tabName = tabName;
        button.onclick = () => switchTab(tabName);

        if (tabName !== 'Notes' && tabName !== 'Roles') {
            const closeBtn = document.createElement('span');
            closeBtn.classList.add('close-tab-btn');
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeTab(tabName);
            };
            button.appendChild(closeBtn);
        }

        return button;
    }
    // --- New Function: Role Consolidation ---
/**
 * Groups all assigned roles from the roleCards array by player name.
 * @returns {Array<Object>} An array of consolidated player objects.
 */
// --- New State Variable to track the currently visible role for each player ---
let playerActiveRoleIndex = {};

// --- Core Role Consolidation Logic (REQUIRED) ---
/**
 * Groups all assigned roles from the roleCards array by player name.
 */
function consolidateRoles() {
    const playersMap = {};
    if (!Array.isArray(roleCards)) return []; 
    
    roleCards.forEach(card => {
        const playerName = card.player.trim().toLowerCase();
        if (!playersMap[playerName]) {
            playersMap[playerName] = { name: playerName, roles: [] };
        }
        if (Array.isArray(card.roles)) {
            card.roles.forEach(r => {
                playersMap[playerName].roles.push({ role: r.role, certainty: r.certainty });
            });
        } else if (card.role) {
            playersMap[playerName].roles.push({ role: card.role, certainty: card.certainty });
        }
    });
    // Sort roles by certainty
    Object.values(playersMap).forEach(player => {
        player.roles.sort((a, b) => {
            if (a.certainty === 'not') return 1;
            if (b.certainty === 'not') return -1;
            return 0;
        });
    });
    return Object.values(playersMap);
}

// --- Essential Helper Functions ---
function getConsolidatedRolesForPlayer(playerName) {
    const consolidated = consolidateRoles(); 
    return consolidated.find(p => p.name.toLowerCase() === playerName.toLowerCase());
}

function deleteRoleCardByPlayerName(playerName) {
    roleCards = roleCards.filter(card => card.player.trim().toLowerCase() !== playerName.toLowerCase());
    delete playerActiveRoleIndex[playerName];
    renderRoleCards();
    saveTabs();
}

/**
 * Updates the visible role index for a player and re-renders the card.
 */
function cyclePlayerRole(playerName, direction) {
    const playerRolesData = getConsolidatedRolesForPlayer(playerName);
    if (!playerRolesData || playerRolesData.roles.length <= 1) return;

    const numRoles = playerRolesData.roles.length;
    let currentIndex = playerActiveRoleIndex[playerName] || 0;

    let newIndex = currentIndex + direction;

    // Handle circular wrapping
    if (newIndex < 0) {
        newIndex = numRoles - 1;
    } else if (newIndex >= numRoles) {
        newIndex = 0;
    }

    playerActiveRoleIndex[playerName] = newIndex;
    
    // Find the old card and replace it with the newly generated card
    const oldCard = rolesContentDiv.querySelector(`.role-card[data-player="${playerName}"]`);
    if (oldCard) {
        const newCard = createRoleCardElement(playerRolesData); 
        rolesContentDiv.replaceChild(newCard, oldCard);
    }
}

// --- Modified Function: Role Card Element Creation (Core Logic) ---
function createRoleCardElement(playerData) {
    const card = document.createElement('div');
    card.classList.add('role-card');
    card.dataset.player = playerData.name;
    // ...existing code...

    const activeIndex = typeof playerActiveRoleIndex[playerData.name] === 'number' ? playerActiveRoleIndex[playerData.name] : 0;
    const activeRole = playerData.roles[activeIndex];
    // Case-insensitive color lookup for roles and modifiers
    let roleColor = '#ffffff';
    const roleKey = activeRole.role ? activeRole.role.trim().toLowerCase() : '';
    for (const key in roleColors) {
        if (key.toLowerCase() === roleKey) {
            roleColor = roleColors[key];
            break;
        }
    }
    if (roleColor === '#ffffff') {
        for (const key in modifierColors) {
            if (key.toLowerCase() === roleKey) {
                roleColor = modifierColors[key];
                break;
            }
        }
    }
    // Set --role-color for all children to inherit
    card.style.setProperty('--role-color', roleColor);
    card.style.setProperty('--main-color', roleColor);
    card.style.borderColor = roleColor;
    card.style.backgroundColor = `#000000`; // 7% opacity
    card.style.boxShadow = `0 0 8px ${roleColor}33, inset 0 0 4px ${roleColor}22`;
    // --- Delete Button ---
    const deleteButton = document.createElement('span');
    deleteButton.classList.add('delete-role-card-button');
    deleteButton.innerHTML = '&times;';
    deleteButton.dataset.player = playerData.name;
    card.appendChild(deleteButton);
    // --- Player Name ---
    const nameDiv = document.createElement('div');
    nameDiv.classList.add('role-card-name');
    nameDiv.textContent = playerData.name;
    card.appendChild(nameDiv);
    // --- Role Icon ---
    const roleData = findRoleData(activeRole.role);
    const roleIconUrl = roleData 
        ? (roleData.category === "Role" ? getRoleImageUrl(roleData.icon) : getModifierImageUrl(roleData.icon)) 
        : 'Media/DefaultIcon.png';
    const iconDiv = document.createElement('div');
    iconDiv.classList.add('role-card-icon');
    iconDiv.style.filter = `drop-shadow(0 0 8px ${roleColor})`;
    iconDiv.innerHTML = `<img src="${roleIconUrl}" style="background:none;" class="w-full h-full object-contain" alt="${activeRole.role} icon" onerror="this.onerror=null;this.src='Media/DefaultIcon.png';">`;
    card.appendChild(iconDiv);
    // --- Role Display Container (Structure for Cycling & Dropdown) ---
    const roleContainer = document.createElement('div');
    roleContainer.classList.add('role-card-cycle-container');
    if (playerData.roles.length > 1) {
        // Custom dropdown: button + menu
        const dropdownWrapper = document.createElement('div');
        dropdownWrapper.style.position = 'relative';
        dropdownWrapper.style.width = '100%';

    const activeButton = document.createElement('button');
    activeButton.classList.add('role-card-dropdown');
    // make the chevron positioning work
    activeButton.style.position = 'relative';
    activeButton.style.display = 'flex';
    activeButton.style.justifyContent = 'center';
    activeButton.style.alignItems = 'center';
    activeButton.style.gap = '8px';

    // create a centered label container (icon + text)
    const labelContainer = document.createElement('div');
    labelContainer.style.display = 'inline-flex';
    labelContainer.style.alignItems = 'center';
    labelContainer.style.justifyContent = 'center';
    labelContainer.style.gap = '8px';
    labelContainer.style.flex = '1';

    // small icon for the active role
    const activeRoleData = findRoleData(playerData.roles[activeIndex].role);
    const activeIconUrl = activeRoleData ? (activeRoleData.category === 'Role' ? getRoleImageUrl(activeRoleData.icon) : getModifierImageUrl(activeRoleData.icon)) : 'Media/DefaultIcon.png';
    const activeIconImg = document.createElement('img');
    activeIconImg.src = activeIconUrl;
    activeIconImg.alt = playerData.roles[activeIndex].role + ' icon';
    activeIconImg.style.width = '20px';
    activeIconImg.style.height = '20px';
    activeIconImg.style.objectFit = 'contain';
    activeIconImg.style.verticalAlign = 'right';
    activeIconImg.onerror = function() { this.onerror = null; this.src = 'Media/DefaultIcon.png'; };

    const labelTextSpan = document.createElement('span');
    labelTextSpan.textContent = playerData.roles[activeIndex].role + (playerData.roles[activeIndex].certainty ? ` (${playerData.roles[activeIndex].certainty})` : '');
    labelTextSpan.style.fontSize = '20px';
    labelTextSpan.style.fontWeight = '700';
    labelTextSpan.style.textAlign = 'center';
    labelTextSpan.style.lineHeight = '1';
    labelTextSpan.style.color = roleColor; // color the selected role

    labelContainer.appendChild(activeIconImg);
    labelContainer.appendChild(labelTextSpan);

    // append the centered label (no chevron to avoid overlapping text)
    activeButton.appendChild(labelContainer);

    const menu = document.createElement('div');
    menu.classList.add('dropdown-content');
    menu.style.background = '#1f1f1f';
    menu.style.borderRadius = '8px';
    menu.style.marginTop = '6px';
    menu.style.zIndex = '50';
    menu.style.display = 'none';

        playerData.roles.forEach((r, idx) => {
            const item = document.createElement('div');
            item.classList.add('menu-item');
            item.style.cursor = 'pointer';
            item.style.padding = '6px 8px';
            // Determine color for this role
            let itemColor = '#E2E8F0';
            for (const key in roleColors) {
                if (key.toLowerCase() === r.role.toLowerCase()) { itemColor = roleColors[key]; break; }
            }
            if (itemColor === '#E2E8F0') {
                for (const key in modifierColors) {
                    if (key.toLowerCase() === r.role.toLowerCase()) { itemColor = modifierColors[key]; break; }
                }
            }
            item.style.color = itemColor;
            // center icon + text together
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.justifyContent = 'center';

            // add a very small icon to the menu item
            const rData = findRoleData(r.role);
            const iconUrl = rData ? (rData.category === 'Role' ? getRoleImageUrl(rData.icon) : getModifierImageUrl(rData.icon)) : 'Media/DefaultIcon.png';
            const itemIcon = document.createElement('img');
            itemIcon.src = iconUrl;
            itemIcon.alt = r.role + ' icon';
            itemIcon.style.width = '20px';
            itemIcon.style.height = '20px';
            itemIcon.style.objectFit = 'contain';
            itemIcon.style.marginRight = '4px';
            itemIcon.onerror = function() { this.onerror = null; this.src = 'Media/DefaultIcon.png'; };

            const itemText = document.createElement('span');
            itemText.textContent = r.role + (r.certainty ? ` (${r.certainty})` : '');
            itemText.style.fontSize = '18px';
            itemText.style.fontWeight = '600';

            // keep a content wrapper so we can place a small delete button to the right
            const contentWrap = document.createElement('div');
            contentWrap.style.display = 'inline-flex';
            contentWrap.style.alignItems = 'center';
            contentWrap.style.justifyContent = 'center';
            contentWrap.appendChild(itemIcon);
            contentWrap.appendChild(itemText);
            item.appendChild(contentWrap);

            // small delete button for this menu item
            const delBtn = document.createElement('button');
            delBtn.textContent = '\u2715'; // small cross
            delBtn.title = 'Delete this role option';
            delBtn.style.background = 'transparent';
            delBtn.style.border = 'none';
            delBtn.style.color = '#ff6b6b';
            delBtn.style.fontSize = '14px';
            delBtn.style.marginLeft = '10px';
            delBtn.style.cursor = 'pointer';
            delBtn.onclick = (ev) => {
                ev.stopPropagation();
                const playerKey = playerData.name.toLowerCase();
                const roleKey = r.role;
                const certaintyKey = r.certainty || '';
                // remove only the first matching savedRoleLines entry
                const idxToRemove = savedRoleLines.findIndex(obj => obj.player.toLowerCase() === playerKey && obj.role === roleKey && (obj.certainty || '') === certaintyKey);
                if (idxToRemove !== -1) {
                    savedRoleLines.splice(idxToRemove, 1);
                    // Rebuild roleCards and refresh UI
                    rebuildRoleCardsFromSaved();

                    // After rebuild, if this player now has exactly one role, ensure active index is 0
                    const consolidated = consolidateRoles();
                    const p = consolidated.find(pp => pp.name.toLowerCase() === playerKey);
                    if (p) {
                        if (p.roles.length === 1) {
                            playerActiveRoleIndex[playerData.name] = 0;
                        }
                    }
                }
                // Close menu
                menu.style.display = 'none';
                if (currentOpenFloatingMenu) { try { currentOpenFloatingMenu.remove(); } catch (err) {} currentOpenFloatingMenu = null; }
            };
            item.appendChild(delBtn);

            item.onclick = (e) => {
                e.stopPropagation();
                playerActiveRoleIndex[playerData.name] = idx;
                // update the active label (icon + text)
                // replace icon src
                const newRoleData = findRoleData(r.role);
                const newIconUrl = newRoleData ? (newRoleData.category === 'Role' ? getRoleImageUrl(newRoleData.icon) : getModifierImageUrl(newRoleData.icon)) : 'Media/DefaultIcon.png';
                activeIconImg.src = newIconUrl;
                activeIconImg.alt = r.role + ' icon';
                labelTextSpan.textContent = r.role + (r.certainty ? ` (${r.certainty})` : '');
                // recolor selected label
                let selColor = '#fff';
                for (const key in roleColors) { if (key.toLowerCase() === r.role.toLowerCase()) { selColor = roleColors[key]; break; } }
                if (selColor === '#fff') {
                    for (const key in modifierColors) { if (key.toLowerCase() === r.role.toLowerCase()) { selColor = modifierColors[key]; break; } }
                }
                labelTextSpan.style.color = selColor;
                activeIconImg.style.filter = `drop-shadow(0 0 6px ${selColor})`;
                menu.style.display = 'none';
                // animate the card briefly to show the change
                const parentCard = activeButton.closest('.role-card');
                if (parentCard) {
                    parentCard.classList.add('animate-role-change');
                    parentCard.addEventListener('animationend', function _rc() { parentCard.classList.remove('animate-role-change'); parentCard.removeEventListener('animationend', _rc); });
                }
                if (activeTab === 'Roles') renderRolesTab();
            };
            menu.appendChild(item);
        });

        activeButton.onclick = (e) => {
            e.stopPropagation();
            // Close any other open menu
            if (currentOpenFloatingMenu && currentOpenFloatingMenu !== menu) {
                try { currentOpenFloatingMenu.remove(); } catch (err) {}
                currentOpenFloatingMenu = null;
            }

            // If menu is already attached, remove it
            if (menu.parentNode === document.body) {
                menu.remove();
                currentOpenFloatingMenu = null;
                return;
            }

            // Position the floating menu based on button rect and append to body so it's on top layer
            const rect = activeButton.getBoundingClientRect();
            menu.style.display = 'block';
            menu.style.position = 'absolute';
            // Determine menu width: at least the button width, but clamp to reasonable max
            const minW = Math.max(120, rect.width);
            const maxW = 380; // don't let menu get too wide
            const menuWidth = Math.min(minW, maxW);
            menu.style.width = `${menuWidth}px`;
            // place below the button; if not enough space, place above
            const belowTop = rect.bottom + 6;
            const estimatedHeight = Math.min(300, playerData.roles.length * 36 + 12);
            if (belowTop + estimatedHeight > window.innerHeight) {
                // place above
                menu.style.top = `${Math.max(8, rect.top - estimatedHeight)}px`;
            } else {
                menu.style.top = `${Math.max(8, belowTop)}px`;
            }
            // clamp left so menu doesn't overflow the viewport
            let left = rect.left;
            if (left + menuWidth > window.innerWidth - 8) {
                left = Math.max(8, window.innerWidth - menuWidth - 8);
            }
            menu.style.left = `${left}px`;
            menu.style.zIndex = '10000';
            menu.style.boxShadow = '0 8px 24px rgba(0,0,0,0.6)';
            document.body.appendChild(menu);
            currentOpenFloatingMenu = menu;
            // animate menu open
            menu.classList.add('animate-menu-open');
        };

        // attach the button and the (non-attached) menu placeholder to the card UI
        dropdownWrapper.appendChild(activeButton);
        roleContainer.appendChild(dropdownWrapper);
    }
    if (playerData.roles.length === 1) {
        const singleRoleDiv = document.createElement('div');
        singleRoleDiv.classList.add('role-card-role');
        singleRoleDiv.textContent = activeRole.role;
        // ensure single-role label uses the computed role color and consistent sizing
        singleRoleDiv.style.color = roleColor;
        singleRoleDiv.style.fontSize = '20px';
        singleRoleDiv.style.fontWeight = '700';
        roleContainer.appendChild(singleRoleDiv);
    }
    card.appendChild(roleContainer);
    return card;
}

// --- New Function: Role Card Rendering ---
function renderRoleCards() {
    rolesContentDiv.innerHTML = '';
    const consolidated = consolidateRoles();
    
    consolidated.forEach(playerData => {
        const cardElement = createRoleCardElement(playerData);
        rolesContentDiv.appendChild(cardElement);
    });
}

// --- Modified Function: Render all role cards ---
/**
 * Clears the rolesContentDiv and re-renders all consolidated role cards.
 */
function renderRoleCards() {
    rolesContentDiv.innerHTML = '';
    
    // 1. Consolidate roles by player
    const consolidatedPlayers = consolidateRoles();

    // 2. Render cards
    consolidatedPlayers.forEach(playerData => {
        // Get the index of the first role for the player (used for deletion/editing)
        const firstRoleCard = roleCards.find(rc => rc.player.trim() === playerData.name.trim());
        if (firstRoleCard) {
            const originalIndex = roleCards.indexOf(firstRoleCard);
            const cardElement = createRoleCardElement(playerData, originalIndex);
            rolesContentDiv.appendChild(cardElement);
        }
    });

    saveTabs();
}

// --- New Function: Dropdown Toggling ---
/**
 * Toggles the visibility of the dropdown content.
 * @param {Event} e - The click event.
 * @param {string} dropdownId - The ID of the dropdown content element.
 */
function toggleDropdown(e, dropdownId) {
    e.stopPropagation(); // Prevent card click logic if any
    
    const content = document.getElementById(dropdownId);
    
    // Hide all other open dropdowns
    document.querySelectorAll('.dropdown-content.show').forEach(openDropdown => {
        if (openDropdown.id !== dropdownId) {
            openDropdown.classList.remove('show');
        }
    });
    
    // Toggle the current dropdown
    if (content) {
        content.classList.toggle('show');
    }
}


// --- New Global Click Listener for Hiding Dropdowns ---
window.addEventListener('click', () => {
    // Hide all dropdowns when clicking anywhere else on the page
    document.querySelectorAll('.dropdown-content.show').forEach(openDropdown => {
        openDropdown.classList.remove('show');
    });
});

// Close any floating menu when clicking elsewhere
window.addEventListener('click', (e) => {
    if (currentOpenFloatingMenu) {
        try { currentOpenFloatingMenu.remove(); } catch (err) {}
        currentOpenFloatingMenu = null;
    }
});

    function switchTab(tabName) {
        if (activeTab) {
            const currentActiveButton = tabsContainer.querySelector(`.tab-button[data-tab-name="${activeTab}"]`);
            if (currentActiveButton) {
                currentActiveButton.classList.remove('active');
            }
        }
        activeTab = tabName;
        const newActiveButton = tabsContainer.querySelector(`.tab-button[data-tab-name="${activeTab}"]`);
        if (newActiveButton) {
            newActiveButton.classList.add('active');
        }

        renderContent();
    }

    function closeTab(tabName) {
        if (tabName === 'Notes' || tabName === 'Roles') {
            return;
        }
        delete notesTabs[tabName];
        saveTabs();
        if (activeTab === tabName) {
            const tabNames = Object.keys(notesTabs);
            const newActiveTab = tabNames[tabNames.length - 1] || 'Notes';
            switchTab(newActiveTab);
        }
        loadTabs();
    }

    function getRoleCardHTML(card, index) {
        const roleData = findRoleData(card.role);
        const cardColor = roleData ? roleColors[roleData.name] : '#A0AEC0';
        let iconUrl = "";
        if (roleData) {
            if (roleData.category === "Role") {
                iconUrl = getRoleImageUrl(roleData.name);
            } else if (roleData.category === "Modifier") {
                iconUrl = getModifierImageUrl(roleData.name);
            }
        }
        // Updated: include background and box-shadow in the style attribute
        return `
            <div class="role-card" data-index="${index}" style="border-color:${cardColor}; background:rgba(0,0,0,0.65); box-shadow:0 0 12px ${cardColor}, inset 0 0 6px ${cardColor};">
                <button class="delete-role-card-button" data-index="${index}">&times;</button>
                <div class="role-card-name" contenteditable="true" onblur="updateRoleCard(${index}, 'name', this.innerText)">${card.name}</div>
                <hr style="width:100%; border:0.5px solid #555; margin-bottom:0.2rem;">
                <div class="role-card-role" style="color:${cardColor}; font-weight:700;"  contenteditable="true" onblur="updateRoleCard(${index}, 'role', this.innerText)">${card.role}</div>
                <hr style="width:100%; border:0.5px solid #555; margin-bottom:0.2rem;">
                <div class="role-card-icon" style="filter:drop-shadow(0 0 12px ${cardColor});" ${cardColor};">
                    ${iconUrl ? `<img src="${iconUrl}" alt="${card.role}" style="max-width:100%; max-height:100%; object-fit:contain;">` : ""}
                </div>
            </div>
        `;
    }


    // Save processed role lines as objects for robust tracking
    let savedRoleLines = [];

    // Helper: rebuild roleCards array from savedRoleLines
    function rebuildRoleCardsFromSaved() {
        const allPlayerRolesMap = {};
        const allRoleSourceMap = {};
        const playerNameDisplayMap = {};
        savedRoleLines.forEach(obj => {
            const playerKey = obj.player.toLowerCase();
            playerNameDisplayMap[playerKey] = obj.player;
            if (!allPlayerRolesMap[playerKey]) allPlayerRolesMap[playerKey] = [];
            if (!allRoleSourceMap[playerKey]) allRoleSourceMap[playerKey] = [];
            const key = obj.role.toLowerCase() + '|' + obj.certainty;
            if (!allPlayerRolesMap[playerKey].some(r => r.role.toLowerCase() + '|' + r.certainty === key)) {
                allPlayerRolesMap[playerKey].push({ role: obj.role, certainty: obj.certainty });
                allRoleSourceMap[playerKey].push(obj.line);
            }
        });
        roleCards = [];
        Object.entries(allPlayerRolesMap).forEach(([playerKey, roles]) => {
            roleCards.push({ player: playerNameDisplayMap[playerKey], roles, sourceLines: allRoleSourceMap[playerKey] });
        });
        saveTabs();
        if (activeTab === 'Roles') renderRolesTab();
    }

    function processTextareaForRoleCards(textarea) {
        const lines = textarea.value.split('\n');
        let updatedLines = [];
        let cardAdded = false;
        const playerRolesMap = {};
        const roleSourceMap = {};
        // Track which lines were processed for deletion
        const processedLineSet = new Set();
        lines.forEach(line => {
            const trimmedLine = line.trim();
            if (trimmedLine) {
                // First check phrase-based patterns
                let phraseMatched = false;
                for (const pat of phraseRolePatterns) {
                    const m = trimmedLine.match(pat.re);
                    if (m) {
                        phraseMatched = true;
                        const playerName = m[1].trim();
                        const playerKey = playerName.toLowerCase();
                        // push each mapped role into savedRoleLines
                        pat.roles.forEach(roleName => {
                            savedRoleLines.push({ line, player: playerName, role: roleName, certainty: '' });
                        });
                        processedLineSet.add(line);
                        cardAdded = true;
                        break;
                    }
                }
                if (phraseMatched) {
                    // matched a phrase, skip the normal "X is Y" parsing for this line
                    return;
                }
                const match = trimmedLine.match(roleCardRegex);
                if (match) {
                    const name = match[1].trim().toLowerCase();
                    const qualifier = match[2] ? match[2].trim() : '';
                    const rolePhrase = match[3].trim();

                    // Split on commas or ' or ' (support optional leading 'either') to allow multiple role candidates
                    let roleCandidates = null;
                    const eitherRegex = /^(?:either\s+)?(.+)$/i;
                    if (/,/.test(rolePhrase)) {
                        // split on comma-separated roles
                        roleCandidates = rolePhrase.split(/\s*,\s*/).map(s => s.trim()).filter(Boolean);
                    } else if (/\bor\b/i.test(rolePhrase)) {
                        // split on ' or ' occurrences
                        roleCandidates = rolePhrase.split(/\s+or\s+/i).map(s => s.trim()).filter(Boolean);
                    } else if (eitherRegex.test(rolePhrase)) {
                        roleCandidates = [rolePhrase];
                    }

                    // Attempt to resolve each candidate to a known role/modifier
                    const matchedRoles = [];
                    if (Array.isArray(roleCandidates)) {
                        roleCandidates.forEach(rc => {
                            const rd = findRoleData(rc);
                            if (rd) matchedRoles.push(rd.name);
                        });
                    }

                    if (matchedRoles.length > 0) {
                        // Save processed line and add all matched roles
                        matchedRoles.forEach(mr => {
                            savedRoleLines.push({ line, player: name, role: mr, certainty: qualifier });
                            if (!playerRolesMap[name]) playerRolesMap[name] = [];
                            if (!roleSourceMap[name]) roleSourceMap[name] = [];
                            playerRolesMap[name].push({ role: mr, certainty: qualifier });
                            roleSourceMap[name].push(line);
                        });
                        processedLineSet.add(line);
                        cardAdded = true;
                    } else {
                        updatedLines.push(line);
                    }
                } else {
                    updatedLines.push(line);
                }
            }
        });
        // Build roleCards from all savedRoleLines, not just current parse
        if (cardAdded) {
            // Group all savedRoleLines by player (case-insensitive), but keep original casing for display
            const allPlayerRolesMap = {};
            const allRoleSourceMap = {};
            const playerNameDisplayMap = {};
            savedRoleLines.forEach(obj => {
                const playerKey = obj.player.toLowerCase();
                // Use the latest casing for display
                playerNameDisplayMap[playerKey] = obj.player;
                if (!allPlayerRolesMap[playerKey]) allPlayerRolesMap[playerKey] = [];
                if (!allRoleSourceMap[playerKey]) allRoleSourceMap[playerKey] = [];
                // Only add if not already present (case-insensitive, same certainty)
                const key = obj.role.toLowerCase() + '|' + obj.certainty;
                if (!allPlayerRolesMap[playerKey].some(r => r.role.toLowerCase() + '|' + r.certainty === key)) {
                    allPlayerRolesMap[playerKey].push({ role: obj.role, certainty: obj.certainty });
                    allRoleSourceMap[playerKey].push(obj.line);
                }
            });
            roleCards = [];
            Object.entries(allPlayerRolesMap).forEach(([playerKey, roles]) => {
                roleCards.push({ player: playerNameDisplayMap[playerKey], roles, sourceLines: allRoleSourceMap[playerKey] });
            });
            textarea.value = lines.filter(line => !processedLineSet.has(line)).join('\n');
            notesTabs[activeTab].content = textarea.value;
            saveTabs();
            if (activeTab === 'Roles') renderRolesTab();
    }
    }

    function deleteRoleCard(index) {
        roleCards.splice(index, 1);
        saveTabs();
        renderRolesTab();
    }

    function updateRoleCard(index, field, newValue) {
        if (roleCards[index]) {
            roleCards[index][field] = newValue.trim();
            if (field === 'role') {
                // Ensure case-insensitive matching with role data
                const roleData = findRoleData(newValue.trim());
                if (roleData) {
                    roleCards[index].role = roleData.name; // Normalize to proper case
                }
            }
            saveTabs();
            renderRolesTab();
        }
    }

    function renderNotepadTab() {
        const content = notesTabs[activeTab].content;
        notesContentDiv.innerHTML = `
            <textarea id="notepadTextarea" class="notepad-textarea custom-scrollable-container w-full h-full">${content}</textarea>
        `;
        const textarea = document.getElementById('notepadTextarea');
        if (textarea) {
            textarea.oninput = (e) => {
                notesTabs[activeTab].content = e.target.value;
                processTextareaForRoleCards(textarea);
            };
            // Keydown handler: when Enter is pressed, attempt to process the current line immediately
            textarea.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') {
                    // find current caret position and extract the current line
                    const pos = textarea.selectionStart;
                    const value = textarea.value;
                    // find start of line
                    let lineStart = value.lastIndexOf('\n', pos - 1);
                    lineStart = lineStart === -1 ? 0 : lineStart + 1;
                    let lineEnd = value.indexOf('\n', pos);
                    lineEnd = lineEnd === -1 ? value.length : lineEnd;
                    const lineText = value.slice(lineStart, lineEnd).trim();
                    if (!lineText) return; // nothing to do

                    // Check phrase patterns
                    let matched = false;
                    for (const pat of phraseRolePatterns) {
                        const m = lineText.match(pat.re);
                        if (m) {
                            matched = true;
                            const playerName = m[1].trim();
                            pat.roles.forEach(roleName => {
                                savedRoleLines.push({ line: lineText, player: playerName, role: roleName, certainty: '' });
                            });
                            break;
                        }
                    }

                    // If not phrase matched, check the "X is Y" pattern and handle comma-separated lists
                    if (!matched) {
                        const m2 = lineText.match(roleCardRegex);
                        if (m2) {
                            matched = true;
                            const playerName = m2[1].trim();
                            const qualifier = m2[2] ? m2[2].trim() : '';
                            let rolePhrase = m2[3].trim();
                            // split on commas or ' or '
                            let candidates = [];
                            if (/\,/.test(rolePhrase)) candidates = rolePhrase.split(/\s*,\s*/).map(s => s.trim()).filter(Boolean);
                            else if (/\bor\b/i.test(rolePhrase)) candidates = rolePhrase.split(/\s+or\s+/i).map(s => s.trim()).filter(Boolean);
                            else candidates = [rolePhrase];
                            candidates.forEach(rc => {
                                // try to normalize using findRoleData, but still save the raw if not found
                                const rd = findRoleData(rc);
                                const roleName = rd ? rd.name : rc;
                                savedRoleLines.push({ line: lineText, player: playerName, role: roleName, certainty: qualifier });
                            });
                            // If PiP canvas is active, ensure input updates are reflected there
                            textarea.addEventListener('input', () => {
                                if (window._pipActive) {
                                    window._pipDirty = true;
                                }
                            });
                        }
                    }

                    // --- Picture-in-Picture for Notepad (DOM capture via html2canvas) ---
                    let pipCanvas = document.getElementById('pipCanvas');
                    let pipVideo = document.getElementById('pipVideo');
                    let pipStream = null;
                    let pipInterval = null;
                    window._pipActive = false;
                    window._pipDirty = false;

                    // Capture one frame of the container into the provided canvas using html2canvas
                    async function pipCaptureFrameOnce(container, canvas) {
                        const tmp = await html2canvas(container, { backgroundColor: null, useCORS: true });
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(tmp, 0, 0, canvas.width, canvas.height);
                    }

                    async function startNotepadPiP() {
                        try {
                            if (!document.pictureInPictureEnabled && !('requestPictureInPicture' in HTMLVideoElement.prototype)) {
                                alert('Picture-in-Picture is not supported in this browser.');
                                return;
                            }
                            const container = document.getElementById('notesContentDiv');
                            if (!container) {
                                alert('Open the Notes tab to enable Notepad PiP.');
                                return;
                            }
                            if (typeof html2canvas !== 'function') {
                                alert('html2canvas is not loaded; cannot capture the notepad container.');
                                return;
                            }
                            pipCanvas = document.getElementById('pipCanvas');
                            pipVideo = document.getElementById('pipVideo');

                            // compute target size for canvas (limit width for performance)
                            const rect = container.getBoundingClientRect();
                            const targetW = Math.min(960, Math.max(320, Math.round(rect.width)));
                            const scale = targetW / Math.max(1, rect.width);
                            const targetH = Math.max(200, Math.round(rect.height * scale));
                            pipCanvas.width = targetW;
                            pipCanvas.height = targetH;

                            // initial capture
                            await pipCaptureFrameOnce(container, pipCanvas);

                            // captureStream at moderate fps
                            const fps = 6;
                            pipStream = pipCanvas.captureStream(fps);
                            pipVideo.srcObject = pipStream;
                            await pipVideo.play().catch(()=>{});
                            console.log('Requesting Picture-in-Picture...');
                            await pipVideo.requestPictureInPicture();
                            window._pipActive = true;

                            // when PiP is closed, cleanup
                            pipVideo.addEventListener('leavepictureinpicture', () => {
                                stopNotepadPiP();
                            }, { once: true });

                            // update frames periodically
                            if (pipInterval) clearInterval(pipInterval);
                            pipInterval = setInterval(() => {
                                pipCaptureFrameOnce(container, pipCanvas).catch(err => console.warn('pip capture err', err));
                            }, 1000 / fps);

                            const btn = document.getElementById('pipToggleButton');
                            if (btn) btn.textContent = 'Exit PiP';
                        } catch (err) {
                            console.error('startNotepadPiP error', err);
                            const msg = (err && err.message) ? err.message : String(err);
                            alert('Could not start Picture-in-Picture. See console for details.\n' + msg);
                        }
                    }

                    async function stopNotepadPiP() {
                        try {
                            if (pipVideo && document.pictureInPictureElement === pipVideo) {
                                try { await document.exitPictureInPicture(); } catch (e) { /* ignore */ }
                            }
                        } finally {
                            window._pipActive = false;
                            window._pipDirty = false;
                            if (pipInterval) { clearInterval(pipInterval); pipInterval = null; }
                            if (pipVideo) { try { pipVideo.pause(); pipVideo.srcObject = null; } catch (e) {} }
                            if (pipStream) { pipStream.getTracks().forEach(t => t.stop()); pipStream = null; }
                            const btn = document.getElementById('pipToggleButton');
                            if (btn) btn.textContent = 'PiP Notepad';
                        }
                    }

                    // Wire PiP toggle button after DOM loads
                    document.addEventListener('DOMContentLoaded', () => {
                        const pipBtn = document.getElementById('pipToggleButton');
                        if (!pipBtn) return;
                        // disable if browser doesn't support PiP request on video + captureStream
                        const supported = (('requestPictureInPicture' in HTMLVideoElement.prototype) || document.pictureInPictureEnabled) && ('captureStream' in HTMLCanvasElement.prototype || typeof HTMLCanvasElement.prototype.captureStream === 'function');
                        if (!supported) {
                            pipBtn.disabled = true;
                            pipBtn.title = 'Picture-in-Picture not supported in this browser';
                            pipBtn.style.opacity = '0.5';
                            return;
                        }
                        pipBtn.onclick = async () => {
                            if (!window._pipActive) {
                                await startNotepadPiP();
                            } else {
                                await stopNotepadPiP();
                            }
                        };
                        // Wire Floating Notepad toggle
                        const floatBtn = document.createElement('button');
                        floatBtn.id = 'floatToggleButton';
                        floatBtn.className = 'bg-gray-800 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-700 transition duration-200 ml-2';
                        floatBtn.textContent = 'Float Notepad';
                        // insert after pip button
                        pipBtn.parentNode && pipBtn.parentNode.insertBefore(floatBtn, pipBtn.nextSibling);

                        floatBtn.onclick = () => {
                            if (!window._isFloating) createFloatingNotepad();
                            else dockNotepad();
                        };

                        // Wire floating pane controls
                        const fpDock = document.getElementById('fpDockBtn');
                        const fpClose = document.getElementById('fpCloseBtn');
                        if (fpDock) fpDock.onclick = dockNotepad;
                        if (fpClose) fpClose.onclick = () => { dockNotepad(); document.getElementById('floatingNotepad').classList.add('hidden'); };
                        // Make header draggable
                        const hdr = document.getElementById('fpHeader');
                        if (hdr) makeElementDraggable(document.getElementById('floatingNotepad'), hdr);
                    });

                    if (matched) {
                        ev.preventDefault();
                        // remove only the processed line from textarea
                        const before = value.slice(0, lineStart);
                        const after = value.slice(lineEnd);
                        const newVal = (before + (after.startsWith('\n') ? after.slice(1) : after)).replace(/^\n/, '');
                        textarea.value = newVal;
                        notesTabs[activeTab].content = textarea.value;
                        // rebuild role cards
                        rebuildRoleCardsFromSaved();
                        return false;
                    }
                }
            });
    }

    // --- Floating notepad logic ---
    window._isFloating = false;
    window._notesOriginalParent = null;
    window._notesOriginalNext = null;

    function createFloatingNotepad() {
        const notes = document.getElementById('notesContentDiv');
        const floating = document.getElementById('floatingNotepad');
        const fpContent = document.getElementById('fpContent');
        if (!notes || !floating || !fpContent) return;
        // save original location
        window._notesOriginalParent = notes.parentNode;
        window._notesOriginalNext = notes.nextSibling;
        // move notes into floating content
        fpContent.appendChild(notes);
        floating.classList.remove('hidden');
        floating.setAttribute('aria-hidden','false');
        window._isFloating = true;
        const floatBtn = document.getElementById('floatToggleButton'); if (floatBtn) floatBtn.textContent = 'Dock Notepad';
    }

    function dockNotepad() {
        const notes = document.getElementById('notesContentDiv');
        if (!notes) return;
        const origParent = window._notesOriginalParent;
        const origNext = window._notesOriginalNext;
        if (origParent) {
            origParent.insertBefore(notes, origNext);
        }
        const floating = document.getElementById('floatingNotepad');
        if (floating) {
            floating.classList.add('hidden');
            floating.setAttribute('aria-hidden','true');
        }
        window._isFloating = false;
        const floatBtn = document.getElementById('floatToggleButton'); if (floatBtn) floatBtn.textContent = 'Float Notepad';
    }

    function makeElementDraggable(el, handle) {
        if (!el || !handle) return;
        handle.style.cursor = 'move';
        let isDown = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
        handle.addEventListener('mousedown', (e) => {
            isDown = true;
            startX = e.clientX;
            startY = e.clientY;
            const rect = el.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            document.body.style.userSelect = 'none';
        });
        document.addEventListener('mousemove', (e) => {
            if (!isDown) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            let left = startLeft + dx;
            let top = startTop + dy;
            // clamp to viewport
            const maxLeft = window.innerWidth - el.offsetWidth - 8;
            const maxTop = window.innerHeight - el.offsetHeight - 8;
            left = Math.min(Math.max(8, left), Math.max(8, maxLeft));
            top = Math.min(Math.max(8, top), Math.max(8, maxTop));
            el.style.left = left + 'px';
            el.style.top = top + 'px';
            el.style.right = 'auto';
            el.style.bottom = 'auto';
            el.style.position = 'fixed';
        });
        document.addEventListener('mouseup', () => { if (isDown) { isDown = false; document.body.style.userSelect = ''; } });
        // touch support
        handle.addEventListener('touchstart', (ev) => {
            const t = ev.touches[0];
            isDown = true; startX = t.clientX; startY = t.clientY; const rect = el.getBoundingClientRect(); startLeft = rect.left; startTop = rect.top; document.body.style.userSelect = 'none';
        }, { passive: true });
        document.addEventListener('touchmove', (ev) => {
            if (!isDown) return; const t = ev.touches[0]; const dx = t.clientX - startX; const dy = t.clientY - startY; let left = startLeft + dx; let top = startTop + dy; const maxLeft = window.innerWidth - el.offsetWidth - 8; const maxTop = window.innerHeight - el.offsetHeight - 8; left = Math.min(Math.max(8, left), Math.max(8, maxLeft)); top = Math.min(Math.max(8, top), Math.max(8, maxTop)); el.style.left = left + 'px'; el.style.top = top + 'px'; el.style.right = 'auto'; el.style.bottom = 'auto'; el.style.position = 'fixed';
        }, { passive: true });
        document.addEventListener('touchend', () => { if (isDown) { isDown = false; document.body.style.userSelect = ''; } });
    }
    }

    function renderRolesTab() {
        const consolidated = consolidateRoles();
        if (consolidated.length === 0) {
            rolesContentDiv.innerHTML = `
                <div style="font-size:30px; align-items:center; margin-left:auto; margin-right:auto" class="text-center text-gray-500 font-weight-700 p-8">
                    No role cards yet.<br>
                    Type a role in any notepad to create one.<br>
                    Example: <span class="text-white font-normal">Someone is probably Impostor</span><br>
                    or <span class="text-white font-normal">Someone is altruist</span>
                </div>
            `;
        } else {
            rolesContentDiv.innerHTML = '';
            consolidated.forEach(playerData => {
                const cardElement = createRoleCardElement(playerData);
                rolesContentDiv.appendChild(cardElement);
                // animate card enter
                cardElement.classList.add('animate-card-enter');
                cardElement.addEventListener('animationend', function _ce() { cardElement.classList.remove('animate-card-enter'); cardElement.removeEventListener('animationend', _ce); });
            });
            rolesContentDiv.style.backgroundColor = '#232323';
            rolesContentDiv.style.borderRadius = '10px';
    }
    }

    function renderContent() {
        rolesContentDiv.classList.add('hidden'); // hide by default
        notesContentDiv.classList.add('hidden'); // hide notes by default

        if (activeTab === 'Roles') {
            rolesContentDiv.classList.remove('hidden');
            rolesContentDiv.style.display = 'flex'; // ensure notesContentDiv is block when switching back
            renderRolesTab();
            // animate the roles container briefly
            rolesContentDiv.classList.add('animate-tab');
            rolesContentDiv.addEventListener('animationend', function _end() { rolesContentDiv.classList.remove('animate-tab'); rolesContentDiv.removeEventListener('animationend', _end); });
        } else {
            notesContentDiv.classList.remove('hidden');
            rolesContentDiv.style.display = 'none'; // ensure rolesContentDiv is block when switching back
            renderNotepadTab();
            // animate notes container briefly
            notesContentDiv.classList.add('animate-tab');
            notesContentDiv.addEventListener('animationend', function _end2() { notesContentDiv.classList.remove('animate-tab'); notesContentDiv.removeEventListener('animationend', _end2); });
        }
    }

    function loadTabs() {
        tabsContainer.innerHTML = '';
        const storedTabs = localStorage.getItem('notesTabs');
        const storedRoleCards = localStorage.getItem('roleCards');

        if (storedTabs) {
            notesTabs = JSON.parse(storedTabs);
        } else {
            notesTabs = {
                'Notes': { content: '' },
                'Roles': { content: '' }
            };
        }
        
        if (storedRoleCards) {
            roleCards = JSON.parse(storedRoleCards);
        }

        Object.keys(notesTabs).forEach(tabName => {
            const button = createTabButton(tabName);
            tabsContainer.appendChild(button);
        });

        if (!notesTabs['Notes']) {
            notesTabs['Notes'] = { content: '' };
        }
        if (!notesTabs['Roles']) {
            notesTabs['Roles'] = { content: '' };
        }

        switchTab(activeTab);
    }

    function resetAllNotes() {
        // Show custom modal instead of native confirm
        const backdrop = document.getElementById('resetModalBackdrop');
        const modal = document.getElementById('resetModal');
        if (backdrop && modal) {
            backdrop.classList.remove('hidden');
            modal.classList.remove('hidden');
            // small entrance animation
            modal.classList.add('animate-tab');
            backdrop.classList.add('animate-tab');
        } else {
            // fallback to direct perform if modal not found
            performReset();
        }
    }

    function performReset() {
        // Add poof animation to each role card
        const cards = Array.from(document.querySelectorAll('.role-card'));
        cards.forEach((c, i) => {
            setTimeout(() => c.classList.add('animate-poof'), i * 40);
        });

        // Add poof to textarea if present
        const ta = document.getElementById('notepadTextarea');
        if (ta) ta.classList.add('animate-poof');

        // After animation finishes (short delay), clear state
        setTimeout(() => {
            notesTabs = {
                'Notes': { content: '' },
                'Roles': { content: '' }
            };
            roleCards = [];
            // Clear saved parsed lines so re-typing old roles doesn't rehydrate cards
            if (Array.isArray(savedRoleLines)) savedRoleLines.length = 0;
            // Reset any active role indices
            playerActiveRoleIndex = {};
            // Close any open floating menu
            if (currentOpenFloatingMenu) { try { currentOpenFloatingMenu.remove(); } catch (err) {} currentOpenFloatingMenu = null; }
            activeTab = 'Notes';
            saveTabs();
            loadTabs();
        }, 480);
    }

    // --- Event Listeners ---
    // Single delegated listener for role card delete buttons
    

    // --- Modified Role Card Event Listener (Handles Delete and Cycling) ---
rolesContentDiv.addEventListener('click', (e) => {
    const deleteButton = e.target.closest('.delete-role-card-button');
    const cycleButton = e.target.closest('.cycle-role-button');

    // 1. Handle Delete (Removes all roles for the player)
    if (deleteButton) {
        const index = deleteButton.dataset.index;
        deleteRoleCard(index);
        e.stopPropagation();
        return;
    }

    // 2. Handle Role Cycling
    if (cycleButton) {
        const playerName = cycleButton.dataset.player;
        // Parse the direction from the button's data attribute
        const direction = parseInt(cycleButton.dataset.direction); 
        cyclePlayerRole(playerName, direction);
        e.stopPropagation();
        return;
    }
});
    addTabButton.addEventListener('click', () => {
        const newTabName = `New Tab ${tabCounter++}`;
        notesTabs[newTabName] = { content: '' };
        saveTabs();
        loadTabs();
        switchTab(newTabName);
    });

    resetButton.addEventListener('click', resetAllNotes);

    // --- Dropdown Menu and Iframe Functionality ---
    dropdownMenu.addEventListener('click', (event) => {
        const dropdownContent = dropdownMenu.querySelector('div');
        if (event.target.tagName === 'A' || event.target.closest('A')) {
            return;
        }
        dropdownContent.classList.toggle('hidden');
    });

    function openIframe(url) {
        dynamicIframe.src = url;
        iframeOverlay.classList.remove('hidden');
        iframeOverlay.classList.add('flex');
    }

    closeIframeButton.addEventListener('click', () => {
        iframeOverlay.classList.remove('flex');
        iframeOverlay.classList.add('hidden');
        dynamicIframe.src = '';
    });

    window.addEventListener('click', (event) => {
    // Close wiki dropdown
    if (!dropdownMenu.contains(event.target)) {
        dropdownMenu.querySelector('div').classList.add('hidden');
    }
    
    // Close role card dropdowns if clicking outside
    if (!event.target.closest('.role-card-dropdown-container')) {
        document.querySelectorAll('.dropdown-content.show').forEach(dropdown => {
            dropdown.classList.remove('show');
        });
    }
});
    // --- Initial Load ---
    document.addEventListener('DOMContentLoaded', () => {
        loadTabs();
    });
        // Wire up reset modal buttons after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            // create modal elements if they don't exist (safety for edits)
            if (!document.getElementById('resetModalBackdrop')) {
                const b = document.createElement('div');
                b.id = 'resetModalBackdrop';
                b.className = 'reset-modal-backdrop hidden';
                document.body.appendChild(b);
            }
            if (!document.getElementById('resetModal')) {
                const m = document.createElement('div');
                m.id = 'resetModal';
                m.className = 'reset-modal hidden';
                m.innerHTML = `<h3>Reset all notes?</h3><p>This will delete all tabs (except default ones) and clear all role cards. This cannot be undone.</p><div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;"><button id="resetCancel" class="btn btn-cancel">Cancel</button><button id="resetConfirm" class="btn btn-confirm">Confirm Reset</button></div>`;
                document.body.appendChild(m);
            }

            const backdrop = document.getElementById('resetModalBackdrop');
            const modal = document.getElementById('resetModal');
            const cancel = document.getElementById('resetCancel');
            const confirm = document.getElementById('resetConfirm');
            if (cancel) cancel.onclick = () => { if (backdrop) backdrop.classList.add('hidden'); if (modal) modal.classList.add('hidden'); };
            if (confirm) confirm.onclick = () => { if (backdrop) backdrop.classList.add('hidden'); if (modal) modal.classList.add('hidden'); performReset(); };
        });
</script>

</body>
</html>